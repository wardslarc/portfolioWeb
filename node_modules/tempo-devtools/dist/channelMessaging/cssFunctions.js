"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ruleMatchesElement = exports.getElementClassList = exports.getCssEvals = exports.cssEval = exports.processRulesForSelectedElement = exports.setModifiersForSelectedElement = exports.parse = void 0;
// @ts-ignore
const jquery_1 = __importDefault(require("jquery"));
const identifierUtils_1 = require("./identifierUtils");
const cssRuleUtils_1 = require("./cssRuleUtils");
const constantsAndTypes_1 = require("./constantsAndTypes");
const uuid_1 = require("uuid");
const specificity_1 = require("specificity");
const tempoElement_1 = require("./tempoElement");
const css_selector_parser_1 = require("css-selector-parser");
const sessionStorageUtils_1 = require("./sessionStorageUtils");
const navTreeUtils_1 = require("./navTreeUtils");
exports.parse = (0, css_selector_parser_1.createParser)({
    syntax: {
        baseSyntax: 'latest',
        pseudoClasses: {
            unknown: 'accept',
            definitions: {
                Selector: ['has'],
            },
        },
        pseudoElements: {
            unknown: 'accept',
        },
        combinators: ['>', '+', '~'],
        attributes: {
            operators: ['^=', '$=', '*=', '~='],
        },
        classNames: true,
        namespace: {
            wildcard: true,
        },
        tag: {
            wildcard: true,
        },
    },
    substitutes: true,
});
const addCSSRule = (styleSheet, selector, rules, index) => {
    try {
        if (styleSheet.insertRule) {
            styleSheet.insertRule(`${selector} { ${rules} }`, index);
        }
        else {
            styleSheet.addRule(selector, rules, index);
        }
    }
    catch (e) {
        console.log('Error adding rule: ', e);
    }
};
/**
 * This method filters and process media query rules for responsive modifiers to extract Tailwind responsive classes.
 * A Tailwind responsive modifiers takes the form:
 *
 *   {sm,md,lg...}:className
 *
 * which is represented as:
 *
 * @media (min-width: 640px) {
 *    .sm\:className {
 *     ...
 *   }
 * }
 *
 * This is why we need to filter for media query rules with min-width and then extract the class name.
 * @param rule
 * @returns
 */
const processMediaQueryRulesForResponsiveModifiers = (rule) => {
    let rules = [];
    if (rule instanceof CSSMediaRule) {
        // Loop through each CSSRule within the CSSMediaRule
        for (let i = 0; i < rule.cssRules.length; i++) {
            const innerRule = rule.cssRules[i];
            // Check for min-width in media queries and that it is a style rule
            if (rule.media.mediaText.includes('min-width') &&
                innerRule instanceof CSSStyleRule) {
                const parsedIsSelector = (0, exports.parse)(innerRule.selectorText);
                if (parsedIsSelector.type !== 'Selector') {
                    continue;
                }
                const lastRule = parsedIsSelector.rules[0];
                const classNames = lastRule.items.filter((item) => item.type === 'ClassName').map((item) => item.name);
                if (classNames.length !== 1) {
                    continue;
                }
                // Extract Tailwind responsive modifiers
                rules.push({
                    class: classNames[0],
                    pseudos: extractTailwindPrefixes(classNames[0]),
                    cssText: innerRule.style.cssText,
                    style: innerRule.style,
                });
            }
        }
    }
    return rules;
};
/**
 * Since Tailwind CSS responsive modifiers are not CSS pseudo classes, we need to extract them from the class name.
 * We use a regex to match the responsive prefixes and return them as a set.
 * @param selectorText
 * @returns Set[prefixes]
 */
const extractTailwindPrefixes = (selectorText) => {
    // This regex matches classes with responsive prefixes that might be preceded by a period or another colon
    const prefixRegex = /(?:\b|(?<=[:.]))(sm|md|lg|xl|2xl)\\?:[\w-]+/g;
    const matches = selectorText.match(prefixRegex) || [];
    const prefixes = matches.map((match) => {
        // Find the index of the colon or escaped colon
        const index = match.indexOf(match.includes('\\:') ? '\\:' : ':');
        return match.substring(0, index);
    });
    return [...new Set(prefixes)]; // Remove duplicates
};
/**
 * Tailwind CSS dark mode classes (< 3.4.1) are specified using the `:is` pseudo selector and take the form
 *   :is(.dark .dark:bg-red-200)
 * This is to support the behaviour that dark mode classes are applied to the element when the dark class is present in the parent.
 *
 * TODO: We should support the new Tailwind CSS dark mode classes in 3.4.1 and above which are specified using the `@media (prefers-color-scheme: dark)` media query.
 * @param isSelectorString
 * @returns
 */
const processIsSelectorForDarkMode = (isSelector) => {
    if (isSelector.type !== 'Selector') {
        return;
    }
    const firstRule = isSelector.rules[0];
    const classNames = firstRule.items.filter((item) => item.type === 'ClassName').map((item) => item.name);
    if (classNames.length === 0 || classNames[0] !== 'dark') {
        return;
    }
    const nestedRule = firstRule.nestedRule;
    if (!nestedRule) {
        return;
    }
    let darkModeClasses = [];
    const nestedClassNames = nestedRule.items.filter((item) => item.type === 'ClassName').map((item) => item.name);
    if (nestedClassNames.length > 1) {
        console.log('Skipping is selector with multiple classes', firstRule);
        return;
    }
    darkModeClasses.push({
        class: nestedClassNames[0],
        pseudos: [
            'dark',
            ...nestedRule.items.filter((item) => item.type === 'PseudoClass').map((p) => p.name),
        ],
    });
    return darkModeClasses;
};
const setModifiersForSelectedElement = (parentPort, modifiers, selectedElementKey) => {
    // Remove all existing force classes from entire document
    const allElements = document.querySelectorAll('[class*="tempo-force-"]');
    allElements.forEach((element) => {
        const classes = Array.from(element.classList);
        classes.forEach((cls) => {
            if (cls.startsWith('tempo-force-')) {
                element.classList.remove(cls);
            }
        });
    });
    const selectedElement = tempoElement_1.TempoElement.fromKey(selectedElementKey);
    if (selectedElement.isEmpty()) {
        return;
    }
    const selectedDomElement = (0, identifierUtils_1.getNodeForElementKey)(selectedElement.getKey());
    if (!selectedDomElement) {
        return;
    }
    modifiers.forEach((modifier) => {
        selectedDomElement.classList.add('tempo-force-' + modifier);
    });
};
exports.setModifiersForSelectedElement = setModifiersForSelectedElement;
const processRulesForSelectedElement = (parentPort, cssElementLookup, selectedElementKey) => {
    var _a, _b, _c, _d, _e;
    // TODO: this whole function is slow, fix
    if (!cssElementLookup) {
        return;
    }
    const selectedElement = tempoElement_1.TempoElement.fromKey(selectedElementKey);
    if (selectedElement.isEmpty()) {
        return;
    }
    const selectedDomElement = (0, identifierUtils_1.getNodeForElementKey)(selectedElement.getKey());
    const multiSelectedElementKeys = (0, sessionStorageUtils_1.getMemoryStorageItem)(sessionStorageUtils_1.MULTI_SELECTED_ELEMENT_KEYS) || [];
    /**
     * If there's no selected DOM element yet, it implies the nav tree isn't built yet.
     * We register a callback to defer the processing of the rules until the nav tree is built.
     */
    if (!selectedDomElement) {
        (0, navTreeUtils_1.addNavTreeBuiltCallback)({
            callbackFn: () => {
                (0, exports.processRulesForSelectedElement)(parentPort, cssElementLookup, selectedElementKey);
            },
            state: {
                selectedElementKey: selectedElementKey,
                multiSelectedElementKeys: multiSelectedElementKeys,
            },
        });
        return;
    }
    const newProcessedCssRules = [];
    const extractedKnownClasses = new Set();
    const knownSelectors = new Set();
    // First get the inline style of the element
    const inlineStyleRule = {
        filename: '',
        selector: 'element.style',
        source: {},
        styles: {},
        applied: true,
        codebaseId: 'element.style',
        removable: false,
        allowChanges: true,
    };
    for (let i = 0; i < ((_a = selectedDomElement === null || selectedDomElement === void 0 ? void 0 : selectedDomElement.style) === null || _a === void 0 ? void 0 : _a.length) || 0; i++) {
        const cssName = selectedDomElement.style[i];
        // @ts-ignore
        inlineStyleRule.styles[cssName] = selectedDomElement.style[cssName];
    }
    newProcessedCssRules.push(inlineStyleRule);
    // Only check the inline-styles of the parent once
    let checkedInlineStylesOfParent = false;
    const directMatchCssRules = [];
    const otherCssRules = [];
    Object.keys(cssElementLookup).forEach((codebaseId) => {
        var _a;
        const cssRule = cssElementLookup[codebaseId];
        knownSelectors.add(cssRule.selector);
        if (!(0, cssRuleUtils_1.isCssSelectorValid)(cssRule.selector)) {
            return;
        }
        (0, cssRuleUtils_1.getAllClassesFromSelector)(cssRule.selector).forEach((cls) => {
            extractedKnownClasses.add(cls);
        });
        // First check if a rule directly matches
        if ((0, cssRuleUtils_1.isCssSelectorValid)(cssRule.selector) &&
            (selectedDomElement === null || selectedDomElement === void 0 ? void 0 : selectedDomElement.matches(cssRule.selector))) {
            directMatchCssRules.push(Object.assign(Object.assign({}, cssRule), { applied: true, allowChanges: true, removable: (0, cssRuleUtils_1.canRemoveCssClassFromElement)(cssRule.selector, selectedDomElement) }));
            return;
        }
        // In order to make the parentElement.style selector unique
        let parentElementIndex = 0;
        // Then check the parents if it's a rule with properties that are inherited
        let parentDomElement = selectedDomElement === null || selectedDomElement === void 0 ? void 0 : selectedDomElement.parentElement;
        const inheritedStyles = {};
        while (parentDomElement) {
            // Inline styles are prioritized over rule based styles
            if (!checkedInlineStylesOfParent) {
                const inlineStyleOfParent = {};
                for (let i = 0; i < ((_a = parentDomElement === null || parentDomElement === void 0 ? void 0 : parentDomElement.style) === null || _a === void 0 ? void 0 : _a.length) || 0; i++) {
                    const cssName = parentDomElement.style[i];
                    if (constantsAndTypes_1.INHERITABLE_CSS_PROPS[cssName]) {
                        inlineStyleOfParent[cssName] = parentDomElement.style[cssName];
                    }
                }
                if (Object.keys(inlineStyleOfParent).length !== 0) {
                    otherCssRules.push({
                        filename: '',
                        // TODO: make this unique
                        selector: `parentElement${parentElementIndex}.style`,
                        inherited: true,
                        source: {},
                        styles: inlineStyleOfParent,
                        applied: true,
                        codebaseId: `parentElement${parentElementIndex}.style`,
                        removable: false,
                        allowChanges: false,
                    });
                }
            }
            // Css defined styles
            if ((0, cssRuleUtils_1.isCssSelectorValid)(cssRule.selector) &&
                !(parentDomElement === null || parentDomElement === void 0 ? void 0 : parentDomElement.matches(cssRule.selector))) {
                parentDomElement = parentDomElement.parentElement;
                continue;
            }
            Object.keys((cssRule === null || cssRule === void 0 ? void 0 : cssRule.styles) || {}).forEach((cssName) => {
                // Prioritize inherited styles that are further down the tree
                if (constantsAndTypes_1.INHERITABLE_CSS_PROPS[cssName] &&
                    inheritedStyles[cssName] !== null) {
                    inheritedStyles[cssName] = cssRule.styles[cssName];
                }
            });
            parentDomElement = parentDomElement.parentElement;
            parentElementIndex += 1;
        }
        // Check once across all css rules
        checkedInlineStylesOfParent = true;
        // Just because a css rule is inherited doesn't mean it can't be eligible to apply,
        // so do not return after appending this rule
        if (Object.keys(inheritedStyles).length !== 0) {
            otherCssRules.push(Object.assign(Object.assign({}, cssRule), { inherited: true, styles: inheritedStyles, applied: true, removable: false, allowChanges: false }));
        }
        // Finally check if it's a rule that can be applied if clases are changed
        otherCssRules.push(Object.assign(Object.assign({}, cssRule), { applied: false, allowChanges: false, eligibleToApply: (0, cssRuleUtils_1.canApplyCssRuleToElement)(cssRule.selector, selectedDomElement) }));
    });
    const mainStyleSheet = document.styleSheets[0];
    // Add any rules not previously added that are available in the stylesheets as read-only
    for (let i = 0; i < document.styleSheets.length; i += 1) {
        const sheet = document.styleSheets[i];
        let rules = null;
        try {
            rules = sheet.cssRules;
        }
        catch (e) {
            console.log(e);
            try {
                rules = sheet.rules;
            }
            catch (e) {
                console.log(e);
            }
        }
        if (!rules) {
            continue;
        }
        for (let j = 0; j < rules.length; j += 1) {
            const rule = rules[j];
            /**
             * Handle Tailwind CSS responsive modifiers
             */
            const responsiveModifiers = processMediaQueryRulesForResponsiveModifiers(rule);
            if (responsiveModifiers.length > 0) {
                for (let k = 0; k < responsiveModifiers.length; k++) {
                    const modifier = responsiveModifiers[k];
                    if (!(selectedDomElement === null || selectedDomElement === void 0 ? void 0 : selectedDomElement.matches('.' + CSS.escape(modifier.class)))) {
                        continue;
                    }
                    const styling = {};
                    for (let l = 0; l < ((_b = modifier === null || modifier === void 0 ? void 0 : modifier.style) === null || _b === void 0 ? void 0 : _b.length) || 0; l += 1) {
                        const cssName = modifier === null || modifier === void 0 ? void 0 : modifier.style[l];
                        // @ts-ignore;
                        styling[cssName] = modifier === null || modifier === void 0 ? void 0 : modifier.style[cssName];
                    }
                    const ruleToPush = {
                        filename: undefined,
                        selector: CSS.escape('.' + modifier.class),
                        classParsed: modifier.class,
                        source: {},
                        styles: styling,
                        applied: true,
                        modifiers: Object.assign({}, modifier.pseudos.reduce((acc, pseudo) => {
                            acc[pseudo] = true;
                            return acc;
                        }, {})),
                        // Generate a random codebase ID to use for selection
                        // Note: this ID is shown as a backup in the overridden tooltip
                        codebaseId: `${modifier.class} ${(0, uuid_1.v4)().toString()}`,
                        removable: false,
                        allowChanges: false,
                        cssText: modifier.cssText,
                    };
                    directMatchCssRules.push(ruleToPush);
                }
            }
            if (!rule.selectorText) {
                continue;
            }
            if (knownSelectors.has(rule.selectorText)) {
                continue;
            }
            const parsedCssRule = (0, exports.parse)(rule.selectorText);
            if (parsedCssRule.type !== 'Selector') {
                continue;
            }
            const firstRule = parsedCssRule.rules[0];
            if (!firstRule) {
                continue;
            }
            /**
             * This is a special case for the `:is` pseudo selector, which is how Tailwind specifies dark mode classes.
             */
            const classNames = firstRule.items.filter((item) => item.type === 'ClassName').map((item) => item.name);
            const pseudos = firstRule.items.filter((item) => item.type === 'PseudoClass');
            // TODO: Add support for https://github.com/tailwindlabs/tailwindcss/pull/13379 (~3.4.4)
            if (classNames.length === 0 &&
                pseudos.length === 1 &&
                pseudos[0].name === 'is') {
                const pseudo = pseudos[0];
                if (pseudo && ((_c = pseudo.argument) === null || _c === void 0 ? void 0 : _c.type) === 'Selector') {
                    const darkModeClasses = processIsSelectorForDarkMode(pseudo.argument);
                    if (darkModeClasses) {
                        for (const darkModeClass of darkModeClasses) {
                            if (!(selectedDomElement === null || selectedDomElement === void 0 ? void 0 : selectedDomElement.matches('.' + CSS.escape(darkModeClass.class)))) {
                                continue;
                            }
                            const styling = {};
                            for (let k = 0; k < ((_d = rule === null || rule === void 0 ? void 0 : rule.style) === null || _d === void 0 ? void 0 : _d.length) || 0; k += 1) {
                                const cssName = rule.style[k];
                                styling[cssName] = rule.style[cssName];
                            }
                            const ruleToPush = {
                                filename: undefined,
                                selector: CSS.escape('.' + darkModeClass.class),
                                classParsed: darkModeClass.class,
                                source: {},
                                styles: styling,
                                applied: true,
                                modifiers: Object.assign({}, darkModeClass.pseudos.reduce((acc, pseudo) => {
                                    acc[pseudo] = true;
                                    return acc;
                                }, {})),
                                // Generate a random codebase ID to use for selection
                                // Note: this ID is shown as a backup in the overridden tooltip
                                codebaseId: `${rule.selectorText} ${(0, uuid_1.v4)().toString()}`,
                                removable: false,
                                allowChanges: false,
                                cssText: rule.style.cssText,
                            };
                            directMatchCssRules.push(ruleToPush);
                        }
                    }
                }
            }
            if (classNames.length === 0 || classNames.length > 1) {
                continue;
            }
            const cls = classNames[0];
            const pseudoClasses = firstRule.items.filter((item) => item.type === 'PseudoClass').map((p) => p.name);
            try {
                if (selectedDomElement === null || selectedDomElement === void 0 ? void 0 : selectedDomElement.matches('.' + CSS.escape(cls))) {
                    const styling = {};
                    for (let k = 0; k < ((_e = rule === null || rule === void 0 ? void 0 : rule.style) === null || _e === void 0 ? void 0 : _e.length) || 0; k += 1) {
                        const cssName = rule.style[k];
                        styling[cssName] = rule.style[cssName];
                    }
                    directMatchCssRules.push({
                        filename: undefined,
                        selector: rule.selectorText,
                        classParsed: cls,
                        source: {},
                        styles: styling,
                        applied: true,
                        modifiers: Object.assign({}, pseudoClasses.reduce((acc, pseudo) => {
                            acc[pseudo.name] = true;
                            return acc;
                        }, {})),
                        // Generate a random codebase ID to use for selection
                        // Note: this ID is shown as a backup in the overridden tooltip
                        codebaseId: `${rule.selectorText} ${(0, uuid_1.v4)().toString()}`,
                        removable: false,
                        allowChanges: false,
                        cssText: rule.style.cssText,
                    });
                }
                else {
                    // console.log("NO MATCH", cls)
                }
            }
            catch (e) {
                // console.error(e);
            }
        }
    }
    // For each direct match rule, check if it has modifiers and create a new rule for each modifier.
    for (let i = 0; i < directMatchCssRules.length; i++) {
        const currentRule = directMatchCssRules[i];
        if (!currentRule.modifiers) {
            continue;
        }
        const rulePseudos = Object.keys(currentRule.modifiers);
        if (rulePseudos.length < 1) {
            continue;
        }
        const cls = currentRule.classParsed;
        if (!cls) {
            continue;
        }
        const cssText = currentRule.cssText;
        if (!cssText) {
            continue;
        }
        // Create a new custom css rule for ones that have pseudo selectors.
        // Use the parseClass as the selector and add `tempo-force-[pseudo]` for each pseudo selector
        const pseudoSelector = rulePseudos
            .map((pseudo) => '.tempo-force-' + pseudo)
            .join('');
        const newSelector = '.' + CSS.escape(cls) + pseudoSelector;
        const newRules = cssText;
        // // Inject new rule into the stylesheet
        addCSSRule(mainStyleSheet, newSelector, newRules, mainStyleSheet.cssRules.length);
    }
    const newList = newProcessedCssRules
        .concat(directMatchCssRules.sort((a, b) => {
        try {
            return -(0, specificity_1.compare)(a.selector, b.selector);
        }
        catch (_a) {
            // Put the invalid elements at the end
            let aValid = true;
            try {
                (0, specificity_1.compare)(a.selector, 'body');
            }
            catch (e) {
                aValid = false;
            }
            let bValid = true;
            try {
                (0, specificity_1.compare)(b.selector, 'body');
            }
            catch (e) {
                bValid = false;
            }
            if (aValid && !bValid) {
                return -1;
            }
            if (!aValid && bValid) {
                return 1;
            }
            return 0;
        }
    }))
        .concat(otherCssRules);
    parentPort.postMessage({
        id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.PROCESSED_CSS_RULES_FOR_ELEMENT,
        processedCssRules: newList,
    });
};
exports.processRulesForSelectedElement = processRulesForSelectedElement;
const cssEval = (element, property) => {
    return window.getComputedStyle(element, null).getPropertyValue(property);
};
exports.cssEval = cssEval;
const getCssEvals = (parentPort, selectedElementKey) => {
    var _a;
    let cssEvals = {};
    const selectdElement = tempoElement_1.TempoElement.fromKey(selectedElementKey);
    if (selectdElement.isEmpty()) {
        return;
    }
    const selectedDomElement = (0, identifierUtils_1.getNodeForElementKey)(selectdElement.getKey());
    if (!selectedDomElement) {
        return;
    }
    constantsAndTypes_1.CSS_VALUES_TO_COLLECT.forEach((cssName) => {
        cssEvals[cssName] = (0, exports.cssEval)(selectedDomElement, cssName);
    });
    const parentCssEvals = {};
    const parentElement = selectedDomElement.parentElement;
    if (parentElement) {
        constantsAndTypes_1.CSS_VALUES_TO_COLLECT_FOR_PARENT.forEach((cssName) => {
            parentCssEvals[cssName] = (0, exports.cssEval)(selectedDomElement.parentElement, cssName);
        });
        // Use jQuery to check if 'dark' class is in any ancestor of the parent element
        let darkEnabledInParent = ((_a = (0, jquery_1.default)((0, identifierUtils_1.getNodeForElementKey)(selectdElement.getKey()))) === null || _a === void 0 ? void 0 : _a.closest('.dark').length) > 0;
        parentCssEvals['darkEnabledInParent'] = darkEnabledInParent;
    }
    cssEvals['parent'] = parentCssEvals;
    parentPort.postMessage({
        id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.CSS_EVALS_FOR_ELEMENT,
        cssEvals,
    });
};
exports.getCssEvals = getCssEvals;
const getElementClassList = (parentPort, selectedElementKey) => {
    const selectdElement = tempoElement_1.TempoElement.fromKey(selectedElementKey);
    if (selectdElement.isEmpty()) {
        return;
    }
    const selectedDomElement = (0, identifierUtils_1.getNodeForElementKey)(selectdElement.getKey());
    if (!selectedDomElement) {
        return;
    }
    parentPort.postMessage({
        id: constantsAndTypes_1.FIXED_IFRAME_MESSAGE_IDS.ELEMENT_CLASS_LIST,
        classList: Array.from(selectedDomElement.classList),
    });
};
exports.getElementClassList = getElementClassList;
const ruleMatchesElement = (parentPort, messageId, rule, selectedElementKey) => {
    if (!rule) {
        return;
    }
    const selectdElement = tempoElement_1.TempoElement.fromKey(selectedElementKey);
    if (selectdElement.isEmpty()) {
        return;
    }
    const selectedDomElement = (0, identifierUtils_1.getNodeForElementKey)(selectdElement.getKey());
    if (!selectedDomElement) {
        return;
    }
    parentPort.postMessage({
        id: messageId,
        matches: selectedDomElement === null || selectedDomElement === void 0 ? void 0 : selectedDomElement.matches(rule),
    });
};
exports.ruleMatchesElement = ruleMatchesElement;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3NzRnVuY3Rpb25zLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2NoYW5uZWxNZXNzYWdpbmcvY3NzRnVuY3Rpb25zLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLGFBQWE7QUFDYixvREFBdUI7QUFDdkIsdURBQXlEO0FBQ3pELGlEQUt3QjtBQUN4QiwyREFLNkI7QUFDN0IsK0JBQW9DO0FBQ3BDLDZDQUErRDtBQUMvRCxpREFBOEM7QUFDOUMsNkRBSzZCO0FBQzdCLCtEQUcrQjtBQUMvQixpREFBeUQ7QUFFNUMsUUFBQSxLQUFLLEdBQUcsSUFBQSxrQ0FBWSxFQUFDO0lBQ2hDLE1BQU0sRUFBRTtRQUNOLFVBQVUsRUFBRSxRQUFRO1FBQ3BCLGFBQWEsRUFBRTtZQUNiLE9BQU8sRUFBRSxRQUFRO1lBQ2pCLFdBQVcsRUFBRTtnQkFDWCxRQUFRLEVBQUUsQ0FBQyxLQUFLLENBQUM7YUFDbEI7U0FDRjtRQUNELGNBQWMsRUFBRTtZQUNkLE9BQU8sRUFBRSxRQUFRO1NBQ2xCO1FBQ0QsV0FBVyxFQUFFLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLENBQUM7UUFDNUIsVUFBVSxFQUFFO1lBQ1YsU0FBUyxFQUFFLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDO1NBQ3BDO1FBQ0QsVUFBVSxFQUFFLElBQUk7UUFDaEIsU0FBUyxFQUFFO1lBQ1QsUUFBUSxFQUFFLElBQUk7U0FDZjtRQUNELEdBQUcsRUFBRTtZQUNILFFBQVEsRUFBRSxJQUFJO1NBQ2Y7S0FDRjtJQUNELFdBQVcsRUFBRSxJQUFJO0NBQ2xCLENBQUMsQ0FBQztBQWtCSCxNQUFNLFVBQVUsR0FBRyxDQUNqQixVQUFlLEVBQ2YsUUFBZ0IsRUFDaEIsS0FBYSxFQUNiLEtBQWEsRUFDYixFQUFFO0lBQ0YsSUFBSTtRQUNGLElBQUksVUFBVSxDQUFDLFVBQVUsRUFBRTtZQUN6QixVQUFVLENBQUMsVUFBVSxDQUFD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QUV6RSxJQUFJLENBQUMsa0JBQWtCLEVBQUU7UUFDdkIsT0FBTztLQUNSO0lBRUQsVUFBVSxDQUFDLFdBQVcsQ0FBQztRQUNyQixFQUFFLEVBQUUsU0FBUztRQUNiLE9BQU8sRUFBRSxrQkFBa0IsYUFBbEIsa0JBQWtCLHVCQUFsQixrQkFBa0IsQ0FBRSxPQUFPLENBQUMsSUFBSSxDQUFDO0tBQzNDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQztBQTFCVyxRQUFBLGtCQUFrQixzQkEwQjdCIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQHRzLWlnbm9yZVxuaW1wb3J0ICQgZnJvbSAnanF1ZXJ5JztcbmltcG9ydCB7IGdldE5vZGVGb3JFbGVtZW50S2V5IH0gZnJvbSAnLi9pZGVudGlmaWVyVXRpbHMnO1xuaW1wb3J0IHtcbiAgY2FuQXBwbHlDc3NSdWxlVG9FbGVtZW50LFxuICBjYW5SZW1vdmVDc3NDbGFzc0Zyb21FbGVtZW50LFxuICBnZXRBbGxDbGFzc2VzRnJvbVNlbGVjdG9yLFxuICBpc0Nzc1NlbGVjdG9yVmFsaWQsXG59IGZyb20gJy4vY3NzUnVsZVV0aWxzJztcbmltcG9ydCB7XG4gIENTU19WQUxVRVNfVE9fQ09MTEVDVCxcbiAgQ1NTX1ZBTFVFU19UT19DT0xMRUNUX0ZPUl9QQVJFTlQsXG4gIEZJWEVEX0lGUkFNRV9NRVNTQUdFX0lEUyxcbiAgSU5IRVJJVEFCTEVfQ1NTX1BST1BTLFxufSBmcm9tICcuL2NvbnN0YW50c0FuZFR5cGVzJztcbmltcG9ydCB7IHY0IGFzIHV1aWR2NCB9IGZyb20gJ3V1aWQnO1xuaW1wb3J0IHsgY29tcGFyZSBhcyBjc3NTcGVjaWZpY2l0eUNvbXBhcmUgfSBmcm9tICdzcGVjaWZpY2l0eSc7XG5pbXBvcnQgeyBUZW1wb0VsZW1lbnQgfSBmcm9tICcuL3RlbXBvRWxlbWVudCc7XG5pbXBvcnQge1xuICBBc3RDbGFzc05hbWUsXG4gIEFzdFBzZXVkb0NsYXNzLFxuICBBc3RTZWxlY3RvcixcbiAgY3JlYXRlUGFyc2VyLFxufSBmcm9tICdjc3Mtc2VsZWN0b3ItcGFyc2VyJztcbmltcG9ydCB7XG4gIE1VTFRJX1NFTEVDVEVEX0VMRU1FTlRfS0VZUyxcbiAgZ2V0TWVtb3J5U3RvcmFnZUl0ZW0sXG59IGZyb20gJy4vc2Vzc2lvblN0b3JhZ2VVdGlscyc7XG5pbXBvcnQgeyBhZGROYXZUcmVlQnVpbHRDYWxsYmFjayB9IGZyb20gJy4vbmF2VHJlZVV0aWxzJztcblxuZXhwb3J0IGNvbnN0IHBhcnNlID0gY3JlYXRlUGFyc2VyKHtcbiAgc3ludGF4OiB7XG4gICAgYmFzZVN5bnRheDogJ2xhdGVzdCcsXG4gICAgcHNldWRvQ2xhc3Nlczoge1xuICAgICAgdW5rbm93bjogJ2FjY2VwdCcsXG4gICAgICBkZWZpbml0aW9uczoge1xuICAgICAgICBTZWxlY3RvcjogWydoYXMnXSxcbiAgICAgIH0sXG4gICAgfSxcbiAgICBwc2V1ZG9FbGVtZW50czoge1xuICAgICAgdW5rbm93bjogJ2FjY2VwdCcsXG4gICAgfSxcbiAgICBjb21iaW5hdG9yczogWyc+JywgJysnLCAnfiddLFxuICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgIG9wZXJhdG9yczogWydePScsICckPScsICcqPScsICd+PSddLFxuICAgIH0sXG4gICAgY2xhc3NOYW1lczogdHJ1ZSxcbiAgICBuYW1lc3BhY2U6IHtcbiAgICAgIHdpbGRjYXJkOiB0cnVlLFxuICAgIH0sXG4gICAgdGFnOiB7XG4gICAgICB3aWxkY2FyZDogdHJ1ZSxcbiAgICB9LFxuICB9LFxuICBzdWJzdGl0dXRlczogdHJ1ZSxcbn0pO1xuXG5leHBvcnQgaW50ZXJmYWNlIENzc1J1bGUge1xuICBmaWxlbmFtZT86IHN0cmluZztcbiAgc2VsZWN0b3I/OiBzdHJpbmc7XG4gIGF0cnVsZT86IHN0cmluZztcbiAgY29kZWJhc2VJZD86IHN0cmluZztcbiAgc291cmNlPzogYW55O1xuICBzdHlsZXM/OiB7IFtjc3NLZXk6IHN0cmluZ106IHN0cmluZyB9O1xuICBpbmhlcml0ZWQ/OiBib29sZWFuO1xuICBhcHBsaWVkPzogYm9vbGVhbjsgLy8gV2hldGhlciB0aGlzIGNzcyBydWxlIGlzIGFwcGxpZWQgdG8gdGhlIGN1cnJlbnQgZWxlbWVudFxuICByZW1vdmFibGU/OiBib29sZWFuOyAvLyBXaGV0aGVyIHRoaXMgY3NzIHJ1bGUgaXMgcmVtb3ZhYmxlIHdpdGggYSBzaW1wbGUgY2xhc3MgY2hhbmdlXG4gIGFsbG93Q2hhbmdlcz86IGJvb2xlYW47XG4gIG1vZGlmaWVycz86IHsgW21vZGlmaWVyOiBzdHJpbmddOiBib29sZWFuIH07XG4gIGNsYXNzUGFyc2VkPzogc3RyaW5nO1xuICBjc3NUZXh0PzogYW55O1xufVxuXG5jb25zdCBhZGRDU1NSdWxlID0gKFxuICBzdHlsZVNoZWV0OiBhbnksXG4gIHNlbGVjdG9yOiBzdHJpbmcsXG4gIHJ1bGVzOiBzdHJpbmcsXG4gIGluZGV4OiBudW1iZXIsXG4pID0+IHtcbiAgdHJ5IHtcbiAgICBpZiAoc3R5bGVTaGVldC5pbnNlcnRSdWxlKSB7XG4gICAgICBzdHlsZVNoZWV0Lmluc2VydFJ1bGUoYCR7c2VsZWN0b3J9IHsgJHtydWxlc30gfWAsIGluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVTaGVldC5hZGRSdWxlKHNlbGVjdG9yLCBydWxlcywgaW5kZXgpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUubG9nKCdFcnJvciBhZGRpbmcgcnVsZTogJywgZSk7XG4gIH1cbn07XG5cbi8qKlxuICogVGhpcyBtZXRob2QgZmlsdGVycyBhbmQgcHJvY2VzcyBtZWRpYSBxdWVyeSBydWxlcyBmb3IgcmVzcG9uc2l2ZSBtb2RpZmllcnMgdG8gZXh0cmFjdCBUYWlsd2luZCByZXNwb25zaXZlIGNsYXNzZXMuXG4gKiBBIFRhaWx3aW5kIHJlc3BvbnNpdmUgbW9kaWZpZXJzIHRha2VzIHRoZSBmb3JtOlxuICpcbiAqICAge3NtLG1kLGxnLi4ufTpjbGFzc05hbWVcbiAqXG4gKiB3aGljaCBpcyByZXByZXNlbnRlZCBhczpcbiAqXG4gKiBAbWVkaWEgKG1pbi13aWR0aDogNjQwcHgpIHtcbiAqICAgIC5zbVxcOmNsYXNzTmFtZSB7XG4gKiAgICAgLi4uXG4gKiAgIH1cbiAqIH1cbiAqXG4gKiBUaGlzIGlzIHdoeSB3ZSBuZWVkIHRvIGZpbHRlciBmb3IgbWVkaWEgcXVlcnkgcnVsZXMgd2l0aCBtaW4td2lkdGggYW5kIHRoZW4gZXh0cmFjdCB0aGUgY2xhc3MgbmFtZS5cbiAqIEBwYXJhbSBydWxlXG4gKiBAcmV0dXJuc1xuICovXG5jb25zdCBwcm9jZXNzTWVkaWFRdWVyeVJ1bGVzRm9yUmVzcG9uc2l2ZU1vZGlmaWVycyA9IChydWxlOiBhbnkpID0+IHtcbiAgbGV0IHJ1bGVzID0gW107XG5cbiAgaWYgKHJ1bGUgaW5zdGFuY2VvZiBDU1NNZWRpYVJ1bGUpIHtcbiAgICAvLyBMb29wIHRocm91Z2ggZWFjaCBDU1NSdWxlIHdpdGhpbiB0aGUgQ1NTTWVkaWFSdWxlXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBydWxlLmNzc1J1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBpbm5lclJ1bGUgPSBydWxlLmNzc1J1bGVzW2ldO1xuICAgICAgLy8gQ2hlY2sgZm9yIG1pbi13aWR0aCBpbiBtZWRpYSBxdWVyaWVzIGFuZCB0aGF0IGl0IGlzIGEgc3R5bGUgcnVsZVxuICAgICAgaWYgKFxuICAgICAgICBydWxlLm1lZGlhLm1lZGlhVGV4dC5pbmNsdWRlcygnbWluLXdpZHRoJykgJiZcbiAgICAgICAgaW5uZXJSdWxlIGluc3RhbmNlb2YgQ1NTU3R5bGVSdWxlXG4gICAgICApIHtcbiAgICAgICAgY29uc3QgcGFyc2VkSXNTZWxlY3RvciA9IHBhcnNlKGlubmVyUnVsZS5zZWxlY3RvclRleHQpO1xuXG4gICAgICAgIGlmIChwYXJzZWRJc1NlbGVjdG9yLnR5cGUgIT09ICdTZWxlY3RvcicpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxhc3RSdWxlID0gcGFyc2VkSXNTZWxlY3Rvci5ydWxlc1swXTtcblxuICAgICAgICBjb25zdCBjbGFzc05hbWVzOiBzdHJpbmdbXSA9IChcbiAgICAgICAgICBsYXN0UnVsZS5pdGVtcy5maWx0ZXIoXG4gICAgICAgICAgICAoaXRlbSkgPT4gaXRlbS50eXBlID09PSAnQ2xhc3NOYW1lJyxcbiAgICAgICAgICApIGFzIEFzdENsYXNzTmFtZVtdXG4gICAgICAgICkubWFwKChpdGVtKSA9PiBpdGVtLm5hbWUpO1xuXG4gICAgICAgIGlmIChjbGFzc05hbWVzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRXh0cmFjdCBUYWlsd2luZCByZXNwb25zaXZlIG1vZGlmaWVyc1xuICAgICAgICBydWxlcy5wdXNoKHtcbiAgICAgICAgICBjbGFzczogY2xhc3NOYW1lc1swXSxcbiAgICAgICAgICBwc2V1ZG9zOiBleHRyYWN0VGFpbHdpbmRQcmVmaXhlcyhjbGFzc05hbWVzWzBdKSxcbiAgICAgICAgICBjc3NUZXh0OiBpbm5lclJ1bGUuc3R5bGUuY3NzVGV4dCxcbiAgICAgICAgICBzdHlsZTogaW5uZXJSdWxlLnN0eWxlLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcnVsZXM7XG59O1xuXG4vKipcbiAqIFNpbmNlIFRhaWx3aW5kIENTUyByZXNwb25zaXZlIG1vZGlmaWVycyBhcmUgbm90IENTUyBwc2V1ZG8gY2xhc3Nlcywgd2UgbmVlZCB0byBleHRyYWN0IHRoZW0gZnJvbSB0aGUgY2xhc3MgbmFtZS5cbiAqIFdlIHVzZSBhIHJlZ2V4IHRvIG1hdGNoIHRoZSByZXNwb25zaXZlIHByZWZpeGVzIGFuZCByZXR1cm4gdGhlbSBhcyBhIHNldC5cbiAqIEBwYXJhbSBzZWxlY3RvclRleHRcbiAqIEByZXR1cm5zIFNldFtwcmVmaXhlc11cbiAqL1xuY29uc3QgZXh0cmFjdFRhaWx3aW5kUHJlZml4ZXMgPSAoc2VsZWN0b3JUZXh0OiBzdHJpbmcpID0+IHtcbiAgLy8gVGhpcyByZWdleCBtYXRjaGVzIGNsYXNzZXMgd2l0aCByZXNwb25zaXZlIHByZWZpeGVzIHRoYXQgbWlnaHQgYmUgcHJlY2VkZWQgYnkgYSBwZXJpb2Qgb3IgYW5vdGhlciBjb2xvblxuICBjb25zdCBwcmVmaXhSZWdleCA9IC8oPzpcXGJ8KD88PVs6Ll0pKShzbXxtZHxsZ3x4bHwyeGwpXFxcXD86W1xcdy1dKy9nO1xuICBjb25zdCBtYXRjaGVzID0gc2VsZWN0b3JUZXh0Lm1hdGNoKHByZWZpeFJlZ2V4KSB8fCBbXTtcbiAgY29uc3QgcHJlZml4ZXMgPSBtYXRjaGVzLm1hcCgobWF0Y2gpID0+IHtcbiAgICAvLyBGaW5kIHRoZSBpbmRleCBvZiB0aGUgY29sb24gb3IgZXNjYXBlZCBjb2xvblxuICAgIGNvbnN0IGluZGV4ID0gbWF0Y2guaW5kZXhPZihtYXRjaC5pbmNsdWRlcygnXFxcXDonKSA/ICdcXFxcOicgOiAnOicpO1xuICAgIHJldHVybiBtYXRjaC5zdWJzdHJpbmcoMCwgaW5kZXgpO1xuICB9KTtcbiAgcmV0dXJuIFsuLi5uZXcgU2V0KHByZWZpeGVzKV07IC8vIFJlbW92ZSBkdXBsaWNhdGVzXG59O1xuXG4vKipcbiAqIFRhaWx3aW5kIENTUyBkYXJrIG1vZGUgY2xhc3NlcyAoPCAzLjQuMSkgYXJlIHNwZWNpZmllZCB1c2luZyB0aGUgYDppc2AgcHNldWRvIHNlbGVjdG9yIGFuZCB0YWtlIHRoZSBmb3JtXG4gKiAgIDppcyguZGFyayAuZGFyazpiZy1yZWQtMjAwKVxuICogVGhpcyBpcyB0byBzdXBwb3J0IHRoZSBiZWhhdmlvdXIgdGhhdCBkYXJrIG1vZGUgY2xhc3NlcyBhcmUgYXBwbGllZCB0byB0aGUgZWxlbWVudCB3aGVuIHRoZSBkYXJrIGNsYXNzIGlzIHByZXNlbnQgaW4gdGhlIHBhcmVudC5cbiAqXG4gKiBUT0RPOiBXZSBzaG91bGQgc3VwcG9ydCB0aGUgbmV3IFRhaWx3aW5kIENTUyBkYXJrIG1vZGUgY2xhc3NlcyBpbiAzLjQuMSBhbmQgYWJvdmUgd2hpY2ggYXJlIHNwZWNpZmllZCB1c2luZyB0aGUgYEBtZWRpYSAocHJlZmVycy1jb2xvci1zY2hlbWU6IGRhcmspYCBtZWRpYSBxdWVyeS5cbiAqIEBwYXJhbSBpc1NlbGVjdG9yU3RyaW5nXG4gKiBAcmV0dXJuc1xuICovXG5jb25zdCBwcm9jZXNzSXNTZWxlY3RvckZvckRhcmtNb2RlID0gKFxuICBpc1NlbGVjdG9yOiBBc3RTZWxlY3Rvcixcbik6IHsgY2xhc3M6IHN0cmluZzsgcHNldWRvczogc3RyaW5nW10gfVtdIHwgdW5kZWZpbmVkID0+IHtcbiAgaWYgKGlzU2VsZWN0b3IudHlwZSAhPT0gJ1NlbGVjdG9yJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGZpcnN0UnVsZSA9IGlzU2VsZWN0b3IucnVsZXNbMF07XG5cbiAgY29uc3QgY2xhc3NOYW1lcyA9IChcbiAgICBmaXJzdFJ1bGUuaXRlbXMuZmlsdGVyKFxuICAgICAgKGl0ZW0pID0+IGl0ZW0udHlwZSA9PT0gJ0NsYXNzTmFtZScsXG4gICAgKSBhcyBBc3RDbGFzc05hbWVbXVxuICApLm1hcCgoaXRlbSkgPT4gaXRlbS5uYW1lKTtcblxuICBpZiAoY2xhc3NOYW1lcy5sZW5ndGggPT09IDAgfHwgY2xhc3NOYW1lc1swXSAhPT0gJ2RhcmsnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgbmVzdGVkUnVsZSA9IGZpcnN0UnVsZS5uZXN0ZWRSdWxlO1xuXG4gIGlmICghbmVzdGVkUnVsZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxldCBkYXJrTW9kZUNsYXNzZXMgPSBbXTtcbiAgY29uc3QgbmVzdGVkQ2xhc3NOYW1lcyA9IChcbiAgICBuZXN0ZWRSdWxlLml0ZW1zLmZpbHRlcihcbiAgICAgIChpdGVtKSA9PiBpdGVtLnR5cGUgPT09ICdDbGFzc05hbWUnLFxuICAgICkgYXMgQXN0Q2xhc3NOYW1lW11cbiAgKS5tYXAoKGl0ZW0pID0+IGl0ZW0ubmFtZSk7XG5cbiAgaWYgKG5lc3RlZENsYXNzTmFtZXMubGVuZ3RoID4gMSkge1xuICAgIGNvbnNvbGUubG9nKCdTa2lwcGluZyBpcyBzZWxlY3RvciB3aXRoIG11bHRpcGxlIGNsYXNzZXMnLCBmaXJzdFJ1bGUpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGRhcmtNb2RlQ2xhc3Nlcy5wdXNoKHtcbiAgICBjbGFzczogbmVzdGVkQ2xhc3NOYW1lc1swXSxcbiAgICBwc2V1ZG9zOiBbXG4gICAgICAnZGFyaycsXG4gICAgICAuLi4oXG4gICAgICAgIG5lc3RlZFJ1bGUuaXRlbXMuZmlsdGVyKFxuICAgICAgICAgIChpdGVtKSA9PiBpdGVtLnR5cGUgPT09ICdQc2V1ZG9DbGFzcycsXG4gICAgICAgICkgYXMgQXN0UHNldWRvQ2xhc3NbXVxuICAgICAgKS5tYXAoKHApID0+IHAubmFtZSksXG4gICAgXSxcbiAgfSk7XG5cbiAgcmV0dXJuIGRhcmtNb2RlQ2xhc3Nlcztcbn07XG5cbmV4cG9ydCBjb25zdCBzZXRNb2RpZmllcnNGb3JTZWxlY3RlZEVsZW1lbnQgPSAoXG4gIHBhcmVudFBvcnQ6IGFueSxcbiAgbW9kaWZpZXJzOiBzdHJpbmdbXSxcbiAgc2VsZWN0ZWRFbGVtZW50S2V5OiBzdHJpbmcsXG4pID0+IHtcbiAgLy8gUmVtb3ZlIGFsbCBleGlzdGluZyBmb3JjZSBjbGFzc2VzIGZyb20gZW50aXJlIGRvY3VtZW50XG4gIGNvbnN0IGFsbEVsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2NsYXNzKj1cInRlbXBvLWZvcmNlLVwiXScpO1xuICBhbGxFbGVtZW50cy5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgY29uc3QgY2xhc3NlcyA9IEFycmF5LmZyb20oZWxlbWVudC5jbGFzc0xpc3QpO1xuICAgIGNsYXNzZXMuZm9yRWFjaCgoY2xzKSA9PiB7XG4gICAgICBpZiAoY2xzLnN0YXJ0c1dpdGgoJ3RlbXBvLWZvcmNlLScpKSB7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShjbHMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBjb25zdCBzZWxlY3RlZEVsZW1lbnQgPSBUZW1wb0VsZW1lbnQuZnJvbUtleShzZWxlY3RlZEVsZW1lbnRLZXkpO1xuXG4gIGlmIChzZWxlY3RlZEVsZW1lbnQuaXNFbXB0eSgpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgc2VsZWN0ZWREb21FbGVtZW50OiBhbnkgPSBnZXROb2RlRm9yRWxlbWVudEtleShcbiAgICBzZWxlY3RlZEVsZW1lbnQuZ2V0S2V5KCksXG4gICk7XG5cbiAgaWYgKCFzZWxlY3RlZERvbUVsZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBtb2RpZmllcnMuZm9yRWFjaCgobW9kaWZpZXIpID0+IHtcbiAgICBzZWxlY3RlZERvbUVsZW1lbnQuY2xhc3NMaXN0LmFkZCgndGVtcG8tZm9yY2UtJyArIG1vZGlmaWVyKTtcbiAgfSk7XG59O1xuXG5leHBvcnQgY29uc3QgcHJvY2Vzc1J1bGVzRm9yU2VsZWN0ZWRFbGVtZW50ID0gKFxuICBwYXJlbnRQb3J0OiBhbnksXG4gIGNzc0VsZW1lbnRMb29rdXA6IGFueSxcbiAgc2VsZWN0ZWRFbGVtZW50S2V5OiBzdHJpbmcsXG4pID0+IHtcbiAgLy8gVE9ETzogdGhpcyB3aG9sZSBmdW5jdGlvbiBpcyBzbG93LCBmaXhcbiAgaWYgKCFjc3NFbGVtZW50TG9va3VwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgc2VsZWN0ZWRFbGVtZW50ID0gVGVtcG9FbGVtZW50LmZyb21LZXkoc2VsZWN0ZWRFbGVtZW50S2V5KTtcbiAgaWYgKHNlbGVjdGVkRWxlbWVudC5pc0VtcHR5KCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBzZWxlY3RlZERvbUVsZW1lbnQ6IGFueSA9IGdldE5vZGVGb3JFbGVtZW50S2V5KFxuICAgIHNlbGVjdGVkRWxlbWVudC5nZXRLZXkoKSxcbiAgKTtcblxuICBjb25zdCBtdWx0aVNlbGVjdGVkRWxlbWVudEtleXM6IHN0cmluZ1tdID1cbiAgICBnZXRNZW1vcnlTdG9yYWdlSXRlbShNVUxUSV9TRUxFQ1RFRF9FTEVNRU5UX0tFWVMpIHx8IFtdO1xuXG4gIC8qKlxuICAgKiBJZiB0aGVyZSdzIG5vIHNlbGVjdGVkIERPTSBlbGVtZW50IHlldCwgaXQgaW1wbGllcyB0aGUgbmF2IHRyZWUgaXNuJ3QgYnVpbHQgeWV0LlxuICAgKiBXZSByZWdpc3RlciBhIGNhbGxiYWNrIHRvIGRlZmVyIHRoZSBwcm9jZXNzaW5nIG9mIHRoZSBydWxlcyB1bnRpbCB0aGUgbmF2IHRyZWUgaXMgYnVpbHQuXG4gICAqL1xuICBpZiAoIXNlbGVjdGVkRG9tRWxlbWVudCkge1xuICAgIGFkZE5hdlRyZWVCdWlsdENhbGxiYWNrKHtcbiAgICAgIGNhbGxiYWNrRm46ICgpID0+IHtcbiAgICAgICAgcHJvY2Vzc1J1bGVzRm9yU2VsZWN0ZWRFbGVtZW50KFxuICAgICAgICAgIHBhcmVudFBvcnQsXG4gICAgICAgICAgY3NzRWxlbWVudExvb2t1cCxcbiAgICAgICAgICBzZWxlY3RlZEVsZW1lbnRLZXksXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgc3RhdGU6IHtcbiAgICAgICAgc2VsZWN0ZWRFbGVtZW50S2V5OiBzZWxlY3RlZEVsZW1lbnRLZXksXG4gICAgICAgIG11bHRpU2VsZWN0ZWRFbGVtZW50S2V5czogbXVsdGlTZWxlY3RlZEVsZW1lbnRLZXlzLFxuICAgICAgfSxcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBuZXdQcm9jZXNzZWRDc3NSdWxlczogQ3NzUnVsZVtdID0gW107XG4gIGNvbnN0IGV4dHJhY3RlZEtub3duQ2xhc3NlcyA9IG5ldyBTZXQoKTtcbiAgY29uc3Qga25vd25TZWxlY3RvcnMgPSBuZXcgU2V0KCk7XG5cbiAgLy8gRmlyc3QgZ2V0IHRoZSBpbmxpbmUgc3R5bGUgb2YgdGhlIGVsZW1lbnRcbiAgY29uc3QgaW5saW5lU3R5bGVSdWxlOiBDc3NSdWxlID0ge1xuICAgIGZpbGVuYW1lOiAnJyxcbiAgICBzZWxlY3RvcjogJ2VsZW1lbnQuc3R5bGUnLFxuICAgIHNvdXJjZToge30sXG4gICAgc3R5bGVzOiB7fSxcbiAgICBhcHBsaWVkOiB0cnVlLFxuICAgIGNvZGViYXNlSWQ6ICdlbGVtZW50LnN0eWxlJyxcbiAgICByZW1vdmFibGU6IGZhbHNlLFxuICAgIGFsbG93Q2hhbmdlczogdHJ1ZSxcbiAgfTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWxlY3RlZERvbUVsZW1lbnQ/LnN0eWxlPy5sZW5ndGggfHwgMDsgaSsrKSB7XG4gICAgY29uc3QgY3NzTmFtZSA9IHNlbGVjdGVkRG9tRWxlbWVudC5zdHlsZVtpXTtcblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpbmxpbmVTdHlsZVJ1bGUuc3R5bGVzW2Nzc05hbWVdID0gc2VsZWN0ZWREb21FbGVtZW50LnN0eWxlW2Nzc05hbWVdO1xuICB9XG4gIG5ld1Byb2Nlc3NlZENzc1J1bGVzLnB1c2goaW5saW5lU3R5bGVSdWxlKTtcblxuICAvLyBPbmx5IGNoZWNrIHRoZSBpbmxpbmUtc3R5bGVzIG9mIHRoZSBwYXJlbnQgb25jZVxuICBsZXQgY2hlY2tlZElubGluZVN0eWxlc09mUGFyZW50ID0gZmFsc2U7XG4gIGNvbnN0IGRpcmVjdE1hdGNoQ3NzUnVsZXM6IENzc1J1bGVbXSA9IFtdO1xuICBjb25zdCBvdGhlckNzc1J1bGVzOiBDc3NSdWxlW10gPSBbXTtcblxuICBPYmplY3Qua2V5cyhjc3NFbGVtZW50TG9va3VwKS5mb3JFYWNoKChjb2RlYmFzZUlkOiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCBjc3NSdWxlID0gY3NzRWxlbWVudExvb2t1cFtjb2RlYmFzZUlkXTtcblxuICAgIGtub3duU2VsZWN0b3JzLmFkZChjc3NSdWxlLnNlbGVjdG9yKTtcblxuICAgIGlmICghaXNDc3NTZWxlY3RvclZhbGlkKGNzc1J1bGUuc2VsZWN0b3IpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZ2V0QWxsQ2xhc3Nlc0Zyb21TZWxlY3Rvcihjc3NSdWxlLnNlbGVjdG9yKS5mb3JFYWNoKChjbHM6IHN0cmluZykgPT4ge1xuICAgICAgZXh0cmFjdGVkS25vd25DbGFzc2VzLmFkZChjbHMpO1xuICAgIH0pO1xuXG4gICAgLy8gRmlyc3QgY2hlY2sgaWYgYSBydWxlIGRpcmVjdGx5IG1hdGNoZXNcbiAgICBpZiAoXG4gICAgICBpc0Nzc1NlbGVjdG9yVmFsaWQoY3NzUnVsZS5zZWxlY3RvcikgJiZcbiAgICAgIHNlbGVjdGVkRG9tRWxlbWVudD8ubWF0Y2hlcyhjc3NSdWxlLnNlbGVjdG9yKVxuICAgICkge1xuICAgICAgZGlyZWN0TWF0Y2hDc3NSdWxlcy5wdXNoKHtcbiAgICAgICAgLi4uY3NzUnVsZSxcbiAgICAgICAgYXBwbGllZDogdHJ1ZSxcbiAgICAgICAgYWxsb3dDaGFuZ2VzOiB0cnVlLFxuICAgICAgICByZW1vdmFibGU6IGNhblJlbW92ZUNzc0NsYXNzRnJvbUVsZW1lbnQoXG4gICAgICAgICAgY3NzUnVsZS5zZWxlY3RvcixcbiAgICAgICAgICBzZWxlY3RlZERvbUVsZW1lbnQsXG4gICAgICAgICksXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJbiBvcmRlciB0byBtYWtlIHRoZSBwYXJlbnRFbGVtZW50LnN0eWxlIHNlbGVjdG9yIHVuaXF1ZVxuICAgIGxldCBwYXJlbnRFbGVtZW50SW5kZXggPSAwO1xuXG4gICAgLy8gVGhlbiBjaGVjayB0aGUgcGFyZW50cyBpZiBpdCdzIGEgcnVsZSB3aXRoIHByb3BlcnRpZXMgdGhhdCBhcmUgaW5oZXJpdGVkXG4gICAgbGV0IHBhcmVudERvbUVsZW1lbnQ6IGFueSA9IHNlbGVjdGVkRG9tRWxlbWVudD8ucGFyZW50RWxlbWVudDtcbiAgICBjb25zdCBpbmhlcml0ZWRTdHlsZXM6IGFueSA9IHt9O1xuICAgIHdoaWxlIChwYXJlbnREb21FbGVtZW50KSB7XG4gICAgICAvLyBJbmxpbmUgc3R5bGVzIGFyZSBwcmlvcml0aXplZCBvdmVyIHJ1bGUgYmFzZWQgc3R5bGVzXG4gICAgICBpZiAoIWNoZWNrZWRJbmxpbmVTdHlsZXNPZlBhcmVudCkge1xuICAgICAgICBjb25zdCBpbmxpbmVTdHlsZU9mUGFyZW50OiBhbnkgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJlbnREb21FbGVtZW50Py5zdHlsZT8ubGVuZ3RoIHx8IDA7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGNzc05hbWU6IHN0cmluZyA9IHBhcmVudERvbUVsZW1lbnQuc3R5bGVbaV07XG4gICAgICAgICAgaWYgKElOSEVSSVRBQkxFX0NTU19QUk9QU1tjc3NOYW1lXSkge1xuICAgICAgICAgICAgaW5saW5lU3R5bGVPZlBhcmVudFtjc3NOYW1lXSA9IHBhcmVudERvbUVsZW1lbnQuc3R5bGVbY3NzTmFtZV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhpbmxpbmVTdHlsZU9mUGFyZW50KS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICBvdGhlckNzc1J1bGVzLnB1c2goe1xuICAgICAgICAgICAgZmlsZW5hbWU6ICcnLFxuXG4gICAgICAgICAgICAvLyBUT0RPOiBtYWtlIHRoaXMgdW5pcXVlXG4gICAgICAgICAgICBzZWxlY3RvcjogYHBhcmVudEVsZW1lbnQke3BhcmVudEVsZW1lbnRJbmRleH0uc3R5bGVgLFxuICAgICAgICAgICAgaW5oZXJpdGVkOiB0cnVlLFxuICAgICAgICAgICAgc291cmNlOiB7fSxcbiAgICAgICAgICAgIHN0eWxlczogaW5saW5lU3R5bGVPZlBhcmVudCxcbiAgICAgICAgICAgIGFwcGxpZWQ6IHRydWUsXG4gICAgICAgICAgICBjb2RlYmFzZUlkOiBgcGFyZW50RWxlbWVudCR7cGFyZW50RWxlbWVudEluZGV4fS5zdHlsZWAsXG4gICAgICAgICAgICByZW1vdmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgYWxsb3dDaGFuZ2VzOiBmYWxzZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBDc3MgZGVmaW5lZCBzdHlsZXNcbiAgICAgIGlmIChcbiAgICAgICAgaXNDc3NTZWxlY3RvclZhbGlkKGNzc1J1bGUuc2VsZWN0b3IpICYmXG4gICAgICAgICFwYXJlbnREb21FbGVtZW50Py5tYXRjaGVzKGNzc1J1bGUuc2VsZWN0b3IpXG4gICAgICApIHtcbiAgICAgICAgcGFyZW50RG9tRWxlbWVudCA9IHBhcmVudERvbUVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIE9iamVjdC5rZXlzKGNzc1J1bGU/LnN0eWxlcyB8fCB7fSkuZm9yRWFjaCgoY3NzTmFtZTogc3RyaW5nKSA9PiB7XG4gICAgICAgIC8vIFByaW9yaXRpemUgaW5oZXJpdGVkIHN0eWxlcyB0aGF0IGFyZSBmdXJ0aGVyIGRvd24gdGhlIHRyZWVcbiAgICAgICAgaWYgKFxuICAgICAgICAgIElOSEVSSVRBQkxFX0NTU19QUk9QU1tjc3NOYW1lXSAmJlxuICAgICAgICAgIGluaGVyaXRlZFN0eWxlc1tjc3NOYW1lXSAhPT0gbnVsbFxuICAgICAgICApIHtcbiAgICAgICAgICBpbmhlcml0ZWRTdHlsZXNbY3NzTmFtZV0gPSBjc3NSdWxlLnN0eWxlc1tjc3NOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHBhcmVudERvbUVsZW1lbnQgPSBwYXJlbnREb21FbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgICBwYXJlbnRFbGVtZW50SW5kZXggKz0gMTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBvbmNlIGFjcm9zcyBhbGwgY3NzIHJ1bGVzXG4gICAgY2hlY2tlZElubGluZVN0eWxlc09mUGFyZW50ID0gdHJ1ZTtcblxuICAgIC8vIEp1c3QgYmVjYXVzZSBhIGNzcyBydWxlIGlzIGluaGVyaXRlZCBkb2Vzbid0IG1lYW4gaXQgY2FuJ3QgYmUgZWxpZ2libGUgdG8gYXBwbHksXG4gICAgLy8gc28gZG8gbm90IHJldHVybiBhZnRlciBhcHBlbmRpbmcgdGhpcyBydWxlXG4gICAgaWYgKE9iamVjdC5rZXlzKGluaGVyaXRlZFN0eWxlcykubGVuZ3RoICE9PSAwKSB7XG4gICAgICBvdGhlckNzc1J1bGVzLnB1c2goe1xuICAgICAgICAuLi5jc3NSdWxlLFxuICAgICAgICBpbmhlcml0ZWQ6IHRydWUsXG4gICAgICAgIHN0eWxlczogaW5oZXJpdGVkU3R5bGVzLFxuICAgICAgICBhcHBsaWVkOiB0cnVlLFxuICAgICAgICByZW1vdmFibGU6IGZhbHNlLFxuICAgICAgICBhbGxvd0NoYW5nZXM6IGZhbHNlLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gRmluYWxseSBjaGVjayBpZiBpdCdzIGEgcnVsZSB0aGF0IGNhbiBiZSBhcHBsaWVkIGlmIGNsYXNlcyBhcmUgY2hhbmdlZFxuICAgIG90aGVyQ3NzUnVsZXMucHVzaCh7XG4gICAgICAuLi5jc3NSdWxlLFxuICAgICAgYXBwbGllZDogZmFsc2UsXG4gICAgICBhbGxvd0NoYW5nZXM6IGZhbHNlLFxuICAgICAgZWxpZ2libGVUb0FwcGx5OiBjYW5BcHBseUNzc1J1bGVUb0VsZW1lbnQoXG4gICAgICAgIGNzc1J1bGUuc2VsZWN0b3IsXG4gICAgICAgIHNlbGVjdGVkRG9tRWxlbWVudCxcbiAgICAgICksXG4gICAgfSk7XG4gIH0pO1xuXG4gIGNvbnN0IG1haW5TdHlsZVNoZWV0ID0gZG9jdW1lbnQuc3R5bGVTaGVldHNbMF07XG5cbiAgLy8gQWRkIGFueSBydWxlcyBub3QgcHJldmlvdXNseSBhZGRlZCB0aGF0IGFyZSBhdmFpbGFibGUgaW4gdGhlIHN0eWxlc2hlZXRzIGFzIHJlYWQtb25seVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGRvY3VtZW50LnN0eWxlU2hlZXRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgY29uc3Qgc2hlZXQgPSBkb2N1bWVudC5zdHlsZVNoZWV0c1tpXTtcblxuICAgIGxldCBydWxlcyA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgIHJ1bGVzID0gc2hlZXQuY3NzUnVsZXM7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5sb2coZSk7XG4gICAgICB0cnkge1xuICAgICAgICBydWxlcyA9IHNoZWV0LnJ1bGVzO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXJ1bGVzKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJ1bGVzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICBjb25zdCBydWxlOiBhbnkgPSBydWxlc1tqXTtcblxuICAgICAgLyoqXG4gICAgICAgKiBIYW5kbGUgVGFpbHdpbmQgQ1NTIHJlc3BvbnNpdmUgbW9kaWZpZXJzXG4gICAgICAgKi9cbiAgICAgIGNvbnN0IHJlc3BvbnNpdmVNb2RpZmllcnMgPVxuICAgICAgICBwcm9jZXNzTWVkaWFRdWVyeVJ1bGVzRm9yUmVzcG9uc2l2ZU1vZGlmaWVycyhydWxlKTtcblxuICAgICAgaWYgKHJlc3BvbnNpdmVNb2RpZmllcnMubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHJlc3BvbnNpdmVNb2RpZmllcnMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICBjb25zdCBtb2RpZmllciA9IHJlc3BvbnNpdmVNb2RpZmllcnNba107XG5cbiAgICAgICAgICBpZiAoIXNlbGVjdGVkRG9tRWxlbWVudD8ubWF0Y2hlcygnLicgKyBDU1MuZXNjYXBlKG1vZGlmaWVyLmNsYXNzKSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHN0eWxpbmc6IGFueSA9IHt9O1xuXG4gICAgICAgICAgZm9yIChsZXQgbCA9IDA7IGwgPCBtb2RpZmllcj8uc3R5bGU/Lmxlbmd0aCB8fCAwOyBsICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGNzc05hbWUgPSBtb2RpZmllcj8uc3R5bGVbbF07XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlO1xuICAgICAgICAgICAgc3R5bGluZ1tjc3NOYW1lXSA9IG1vZGlmaWVyPy5zdHlsZVtjc3NOYW1lXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBydWxlVG9QdXNoOiBDc3NSdWxlID0ge1xuICAgICAgICAgICAgZmlsZW5hbWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHNlbGVjdG9yOiBDU1MuZXNjYXBlKCcuJyArIG1vZGlmaWVyLmNsYXNzKSxcbiAgICAgICAgICAgIGNsYXNzUGFyc2VkOiBtb2RpZmllci5jbGFzcyxcbiAgICAgICAgICAgIHNvdXJjZToge30sXG4gICAgICAgICAgICBzdHlsZXM6IHN0eWxpbmcsXG4gICAgICAgICAgICBhcHBsaWVkOiB0cnVlLFxuICAgICAgICAgICAgbW9kaWZpZXJzOiB7XG4gICAgICAgICAgICAgIC4uLm1vZGlmaWVyLnBzZXVkb3MucmVkdWNlKChhY2M6IGFueSwgcHNldWRvOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICBhY2NbcHNldWRvXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgICAgfSwge30pLFxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gR2VuZXJhdGUgYSByYW5kb20gY29kZWJhc2UgSUQgdG8gdXNlIGZvciBzZWxlY3Rpb25cbiAgICAgICAgICAgIC8vIE5vdGU6IHRoaXMgSUQgaXMgc2hvd24gYXMgYSBiYWNrdXAgaW4gdGhlIG92ZXJyaWRkZW4gdG9vbHRpcFxuICAgICAgICAgICAgY29kZWJhc2VJZDogYCR7bW9kaWZpZXIuY2xhc3N9ICR7dXVpZHY0KCkudG9TdHJpbmcoKX1gLFxuICAgICAgICAgICAgcmVtb3ZhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGFsbG93Q2hhbmdlczogZmFsc2UsXG4gICAgICAgICAgICBjc3NUZXh0OiBtb2RpZmllci5jc3NUZXh0LFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBkaXJlY3RNYXRjaENzc1J1bGVzLnB1c2gocnVsZVRvUHVzaCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFydWxlLnNlbGVjdG9yVGV4dCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGtub3duU2VsZWN0b3JzLmhhcyhydWxlLnNlbGVjdG9yVGV4dCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBhcnNlZENzc1J1bGUgPSBwYXJzZShydWxlLnNlbGVjdG9yVGV4dCk7XG5cbiAgICAgIGlmIChwYXJzZWRDc3NSdWxlLnR5cGUgIT09ICdTZWxlY3RvcicpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZpcnN0UnVsZSA9IHBhcnNlZENzc1J1bGUucnVsZXNbMF07XG5cbiAgICAgIGlmICghZmlyc3RSdWxlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UgZm9yIHRoZSBgOmlzYCBwc2V1ZG8gc2VsZWN0b3IsIHdoaWNoIGlzIGhvdyBUYWlsd2luZCBzcGVjaWZpZXMgZGFyayBtb2RlIGNsYXNzZXMuXG4gICAgICAgKi9cbiAgICAgIGNvbnN0IGNsYXNzTmFtZXMgPSAoXG4gICAgICAgIGZpcnN0UnVsZS5pdGVtcy5maWx0ZXIoXG4gICAgICAgICAgKGl0ZW0pID0+IGl0ZW0udHlwZSA9PT0gJ0NsYXNzTmFtZScsXG4gICAgICAgICkgYXMgQXN0Q2xhc3NOYW1lW11cbiAgICAgICkubWFwKChpdGVtKSA9PiBpdGVtLm5hbWUpO1xuXG4gICAgICBjb25zdCBwc2V1ZG9zID0gZmlyc3RSdWxlLml0ZW1zLmZpbHRlcihcbiAgICAgICAgKGl0ZW0pID0+IGl0ZW0udHlwZSA9PT0gJ1BzZXVkb0NsYXNzJyxcbiAgICAgICkgYXMgQXN0UHNldWRvQ2xhc3NbXTtcblxuICAgICAgLy8gVE9ETzogQWRkIHN1cHBvcnQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS90YWlsd2luZGxhYnMvdGFpbHdpbmRjc3MvcHVsbC8xMzM3OSAofjMuNC40KVxuICAgICAgaWYgKFxuICAgICAgICBjbGFzc05hbWVzLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICBwc2V1ZG9zLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICBwc2V1ZG9zWzBdLm5hbWUgPT09ICdpcydcbiAgICAgICkge1xuICAgICAgICBjb25zdCBwc2V1ZG8gPSBwc2V1ZG9zWzBdO1xuICAgICAgICBpZiAocHNldWRvICYmIHBzZXVkby5hcmd1bWVudD8udHlwZSA9PT0gJ1NlbGVjdG9yJykge1xuICAgICAgICAgIGNvbnN0IGRhcmtNb2RlQ2xhc3NlcyA9IHByb2Nlc3NJc1NlbGVjdG9yRm9yRGFya01vZGUocHNldWRvLmFyZ3VtZW50KTtcblxuICAgICAgICAgIGlmIChkYXJrTW9kZUNsYXNzZXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZGFya01vZGVDbGFzcyBvZiBkYXJrTW9kZUNsYXNzZXMpIHtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICFzZWxlY3RlZERvbUVsZW1lbnQ/Lm1hdGNoZXMoXG4gICAgICAgICAgICAgICAgICAnLicgKyBDU1MuZXNjYXBlKGRhcmtNb2RlQ2xhc3MuY2xhc3MpLFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjb25zdCBzdHlsaW5nOiBhbnkgPSB7fTtcbiAgICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBydWxlPy5zdHlsZT8ubGVuZ3RoIHx8IDA7IGsgKz0gMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNzc05hbWUgPSBydWxlLnN0eWxlW2tdO1xuICAgICAgICAgICAgICAgIHN0eWxpbmdbY3NzTmFtZV0gPSBydWxlLnN0eWxlW2Nzc05hbWVdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY29uc3QgcnVsZVRvUHVzaDogQ3NzUnVsZSA9IHtcbiAgICAgICAgICAgICAgICBmaWxlbmFtZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiBDU1MuZXNjYXBlKCcuJyArIGRhcmtNb2RlQ2xhc3MuY2xhc3MpLFxuICAgICAgICAgICAgICAgIGNsYXNzUGFyc2VkOiBkYXJrTW9kZUNsYXNzLmNsYXNzLFxuICAgICAgICAgICAgICAgIHNvdXJjZToge30sXG4gICAgICAgICAgICAgICAgc3R5bGVzOiBzdHlsaW5nLFxuICAgICAgICAgICAgICAgIGFwcGxpZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgbW9kaWZpZXJzOiB7XG4gICAgICAgICAgICAgICAgICAuLi5kYXJrTW9kZUNsYXNzLnBzZXVkb3MucmVkdWNlKChhY2M6IGFueSwgcHNldWRvOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYWNjW3BzZXVkb10gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgICAgICAgfSwge30pLFxuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvLyBHZW5lcmF0ZSBhIHJhbmRvbSBjb2RlYmFzZSBJRCB0byB1c2UgZm9yIHNlbGVjdGlvblxuICAgICAgICAgICAgICAgIC8vIE5vdGU6IHRoaXMgSUQgaXMgc2hvd24gYXMgYSBiYWNrdXAgaW4gdGhlIG92ZXJyaWRkZW4gdG9vbHRpcFxuICAgICAgICAgICAgICAgIGNvZGViYXNlSWQ6IGAke3J1bGUuc2VsZWN0b3JUZXh0fSAke3V1aWR2NCgpLnRvU3RyaW5nKCl9YCxcbiAgICAgICAgICAgICAgICByZW1vdmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGFsbG93Q2hhbmdlczogZmFsc2UsXG4gICAgICAgICAgICAgICAgY3NzVGV4dDogcnVsZS5zdHlsZS5jc3NUZXh0LFxuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIGRpcmVjdE1hdGNoQ3NzUnVsZXMucHVzaChydWxlVG9QdXNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNsYXNzTmFtZXMubGVuZ3RoID09PSAwIHx8IGNsYXNzTmFtZXMubGVuZ3RoID4gMSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY2xzID0gY2xhc3NOYW1lc1swXTtcbiAgICAgIGNvbnN0IHBzZXVkb0NsYXNzZXMgPSAoXG4gICAgICAgIGZpcnN0UnVsZS5pdGVtcy5maWx0ZXIoXG4gICAgICAgICAgKGl0ZW0pID0+IGl0ZW0udHlwZSA9PT0gJ1BzZXVkb0NsYXNzJyxcbiAgICAgICAgKSBhcyBBc3RQc2V1ZG9DbGFzc1tdXG4gICAgICApLm1hcCgocCkgPT4gcC5uYW1lKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHNlbGVjdGVkRG9tRWxlbWVudD8ubWF0Y2hlcygnLicgKyBDU1MuZXNjYXBlKGNscykpKSB7XG4gICAgICAgICAgY29uc3Qgc3R5bGluZzogYW55ID0ge307XG4gICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBydWxlPy5zdHlsZT8ubGVuZ3RoIHx8IDA7IGsgKz0gMSkge1xuICAgICAgICAgICAgY29uc3QgY3NzTmFtZSA9IHJ1bGUuc3R5bGVba107XG4gICAgICAgICAgICBzdHlsaW5nW2Nzc05hbWVdID0gcnVsZS5zdHlsZVtjc3NOYW1lXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkaXJlY3RNYXRjaENzc1J1bGVzLnB1c2goe1xuICAgICAgICAgICAgZmlsZW5hbWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHNlbGVjdG9yOiBydWxlLnNlbGVjdG9yVGV4dCxcbiAgICAgICAgICAgIGNsYXNzUGFyc2VkOiBjbHMsXG4gICAgICAgICAgICBzb3VyY2U6IHt9LFxuICAgICAgICAgICAgc3R5bGVzOiBzdHlsaW5nLFxuICAgICAgICAgICAgYXBwbGllZDogdHJ1ZSxcbiAgICAgICAgICAgIG1vZGlmaWVyczoge1xuICAgICAgICAgICAgICAuLi5wc2V1ZG9DbGFzc2VzLnJlZHVjZSgoYWNjOiBhbnksIHBzZXVkbzogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgYWNjW3BzZXVkby5uYW1lXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgICAgfSwge30pLFxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gR2VuZXJhdGUgYSByYW5kb20gY29kZWJhc2UgSUQgdG8gdXNlIGZvciBzZWxlY3Rpb25cbiAgICAgICAgICAgIC8vIE5vdGU6IHRoaXMgSUQgaXMgc2hvd24gYXMgYSBiYWNrdXAgaW4gdGhlIG92ZXJyaWRkZW4gdG9vbHRpcFxuICAgICAgICAgICAgY29kZWJhc2VJZDogYCR7cnVsZS5zZWxlY3RvclRleHR9ICR7dXVpZHY0KCkudG9TdHJpbmcoKX1gLFxuICAgICAgICAgICAgcmVtb3ZhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGFsbG93Q2hhbmdlczogZmFsc2UsXG4gICAgICAgICAgICBjc3NUZXh0OiBydWxlLnN0eWxlLmNzc1RleHQsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coXCJOTyBNQVRDSFwiLCBjbHMpXG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gY29uc29sZS5lcnJvcihlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBGb3IgZWFjaCBkaXJlY3QgbWF0Y2ggcnVsZSwgY2hlY2sgaWYgaXQgaGFzIG1vZGlmaWVycyBhbmQgY3JlYXRlIGEgbmV3IHJ1bGUgZm9yIGVhY2ggbW9kaWZpZXIuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGlyZWN0TWF0Y2hDc3NSdWxlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGN1cnJlbnRSdWxlID0gZGlyZWN0TWF0Y2hDc3NSdWxlc1tpXTtcbiAgICBpZiAoIWN1cnJlbnRSdWxlLm1vZGlmaWVycykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3QgcnVsZVBzZXVkb3MgPSBPYmplY3Qua2V5cyhjdXJyZW50UnVsZS5tb2RpZmllcnMpO1xuXG4gICAgaWYgKHJ1bGVQc2V1ZG9zLmxlbmd0aCA8IDEpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IGNscyA9IGN1cnJlbnRSdWxlLmNsYXNzUGFyc2VkO1xuXG4gICAgaWYgKCFjbHMpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IGNzc1RleHQgPSBjdXJyZW50UnVsZS5jc3NUZXh0O1xuXG4gICAgaWYgKCFjc3NUZXh0KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgYSBuZXcgY3VzdG9tIGNzcyBydWxlIGZvciBvbmVzIHRoYXQgaGF2ZSBwc2V1ZG8gc2VsZWN0b3JzLlxuICAgIC8vIFVzZSB0aGUgcGFyc2VDbGFzcyBhcyB0aGUgc2VsZWN0b3IgYW5kIGFkZCBgdGVtcG8tZm9yY2UtW3BzZXVkb11gIGZvciBlYWNoIHBzZXVkbyBzZWxlY3RvclxuICAgIGNvbnN0IHBzZXVkb1NlbGVjdG9yID0gcnVsZVBzZXVkb3NcbiAgICAgIC5tYXAoKHBzZXVkbzogc3RyaW5nKSA9PiAnLnRlbXBvLWZvcmNlLScgKyBwc2V1ZG8pXG4gICAgICAuam9pbignJyk7XG4gICAgY29uc3QgbmV3U2VsZWN0b3IgPSAnLicgKyBDU1MuZXNjYXBlKGNscykgKyBwc2V1ZG9TZWxlY3RvcjtcbiAgICBjb25zdCBuZXdSdWxlcyA9IGNzc1RleHQ7XG5cbiAgICAvLyAvLyBJbmplY3QgbmV3IHJ1bGUgaW50byB0aGUgc3R5bGVzaGVldFxuICAgIGFkZENTU1J1bGUoXG4gICAgICBtYWluU3R5bGVTaGVldCxcbiAgICAgIG5ld1NlbGVjdG9yLFxuICAgICAgbmV3UnVsZXMsXG4gICAgICBtYWluU3R5bGVTaGVldC5jc3NSdWxlcy5sZW5ndGgsXG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0IG5ld0xpc3QgPSBuZXdQcm9jZXNzZWRDc3NSdWxlc1xuICAgIC5jb25jYXQoXG4gICAgICBkaXJlY3RNYXRjaENzc1J1bGVzLnNvcnQoKGE6IGFueSwgYjogYW55KSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIC1jc3NTcGVjaWZpY2l0eUNvbXBhcmUoYS5zZWxlY3RvciwgYi5zZWxlY3Rvcik7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIC8vIFB1dCB0aGUgaW52YWxpZCBlbGVtZW50cyBhdCB0aGUgZW5kXG4gICAgICAgICAgbGV0IGFWYWxpZCA9IHRydWU7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNzc1NwZWNpZmljaXR5Q29tcGFyZShhLnNlbGVjdG9yLCAnYm9keScpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGFWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCBiVmFsaWQgPSB0cnVlO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjc3NTcGVjaWZpY2l0eUNvbXBhcmUoYi5zZWxlY3RvciwgJ2JvZHknKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBiVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYVZhbGlkICYmICFiVmFsaWQpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWFWYWxpZCAmJiBiVmFsaWQpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICB9KSxcbiAgICApXG4gICAgLmNvbmNhdChvdGhlckNzc1J1bGVzKTtcblxuICBwYXJlbnRQb3J0LnBvc3RNZXNzYWdlKHtcbiAgICBpZDogRklYRURfSUZSQU1FX01FU1NBR0VfSURTLlBST0NFU1NFRF9DU1NfUlVMRVNfRk9SX0VMRU1FTlQsXG4gICAgcHJvY2Vzc2VkQ3NzUnVsZXM6IG5ld0xpc3QsXG4gIH0pO1xufTtcblxuZXhwb3J0IGNvbnN0IGNzc0V2YWwgPSAoZWxlbWVudDogYW55LCBwcm9wZXJ0eTogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAgcmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldENzc0V2YWxzID0gKHBhcmVudFBvcnQ6IGFueSwgc2VsZWN0ZWRFbGVtZW50S2V5OiBzdHJpbmcpID0+IHtcbiAgbGV0IGNzc0V2YWxzOiBhbnkgPSB7fTtcblxuICBjb25zdCBzZWxlY3RkRWxlbWVudCA9IFRlbXBvRWxlbWVudC5mcm9tS2V5KHNlbGVjdGVkRWxlbWVudEtleSk7XG5cbiAgaWYgKHNlbGVjdGRFbGVtZW50LmlzRW1wdHkoKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHNlbGVjdGVkRG9tRWxlbWVudCA9IGdldE5vZGVGb3JFbGVtZW50S2V5KHNlbGVjdGRFbGVtZW50LmdldEtleSgpKTtcblxuICBpZiAoIXNlbGVjdGVkRG9tRWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIENTU19WQUxVRVNfVE9fQ09MTEVDVC5mb3JFYWNoKChjc3NOYW1lOiBzdHJpbmcpID0+IHtcbiAgICBjc3NFdmFsc1tjc3NOYW1lXSA9IGNzc0V2YWwoc2VsZWN0ZWREb21FbGVtZW50LCBjc3NOYW1lKTtcbiAgfSk7XG5cbiAgY29uc3QgcGFyZW50Q3NzRXZhbHM6IGFueSA9IHt9O1xuXG4gIGNvbnN0IHBhcmVudEVsZW1lbnQgPSBzZWxlY3RlZERvbUVsZW1lbnQucGFyZW50RWxlbWVudDtcblxuICBpZiAocGFyZW50RWxlbWVudCkge1xuICAgIENTU19WQUxVRVNfVE9fQ09MTEVDVF9GT1JfUEFSRU5ULmZvckVhY2goKGNzc05hbWU6IHN0cmluZykgPT4ge1xuICAgICAgcGFyZW50Q3NzRXZhbHNbY3NzTmFtZV0gPSBjc3NFdmFsKFxuICAgICAgICBzZWxlY3RlZERvbUVsZW1lbnQucGFyZW50RWxlbWVudCxcbiAgICAgICAgY3NzTmFtZSxcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICAvLyBVc2UgalF1ZXJ5IHRvIGNoZWNrIGlmICdkYXJrJyBjbGFzcyBpcyBpbiBhbnkgYW5jZXN0b3Igb2YgdGhlIHBhcmVudCBlbGVtZW50XG4gICAgbGV0IGRhcmtFbmFibGVkSW5QYXJlbnQgPVxuICAgICAgJChnZXROb2RlRm9yRWxlbWVudEtleShzZWxlY3RkRWxlbWVudC5nZXRLZXkoKSkgYXMgYW55KT8uY2xvc2VzdCgnLmRhcmsnKVxuICAgICAgICAubGVuZ3RoID4gMDtcblxuICAgIHBhcmVudENzc0V2YWxzWydkYXJrRW5hYmxlZEluUGFyZW50J10gPSBkYXJrRW5hYmxlZEluUGFyZW50O1xuICB9XG5cbiAgY3NzRXZhbHNbJ3BhcmVudCddID0gcGFyZW50Q3NzRXZhbHM7XG5cbiAgcGFyZW50UG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgaWQ6IEZJWEVEX0lGUkFNRV9NRVNTQUdFX0lEUy5DU1NfRVZBTFNfRk9SX0VMRU1FTlQsXG4gICAgY3NzRXZhbHMsXG4gIH0pO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldEVsZW1lbnRDbGFzc0xpc3QgPSAoXG4gIHBhcmVudFBvcnQ6IGFueSxcbiAgc2VsZWN0ZWRFbGVtZW50S2V5OiBzdHJpbmcsXG4pID0+IHtcbiAgY29uc3Qgc2VsZWN0ZEVsZW1lbnQgPSBUZW1wb0VsZW1lbnQuZnJvbUtleShzZWxlY3RlZEVsZW1lbnRLZXkpO1xuXG4gIGlmIChzZWxlY3RkRWxlbWVudC5pc0VtcHR5KCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBzZWxlY3RlZERvbUVsZW1lbnQgPSBnZXROb2RlRm9yRWxlbWVudEtleShzZWxlY3RkRWxlbWVudC5nZXRLZXkoKSk7XG5cbiAgaWYgKCFzZWxlY3RlZERvbUVsZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBwYXJlbnRQb3J0LnBvc3RNZXNzYWdlKHtcbiAgICBpZDogRklYRURfSUZSQU1FX01FU1NBR0VfSURTLkVMRU1FTlRfQ0xBU1NfTElTVCxcbiAgICBjbGFzc0xpc3Q6IEFycmF5LmZyb20oc2VsZWN0ZWREb21FbGVtZW50LmNsYXNzTGlzdCksXG4gIH0pO1xufTtcblxuZXhwb3J0IGNvbnN0IHJ1bGVNYXRjaGVzRWxlbWVudCA9IChcbiAgcGFyZW50UG9ydDogYW55LFxuICBtZXNzYWdlSWQ6IHN0cmluZyxcbiAgcnVsZTogc3RyaW5nLFxuICBzZWxlY3RlZEVsZW1lbnRLZXk6IHN0cmluZyxcbikgPT4ge1xuICBpZiAoIXJ1bGUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBzZWxlY3RkRWxlbWVudCA9IFRlbXBvRWxlbWVudC5mcm9tS2V5KHNlbGVjdGVkRWxlbWVudEtleSk7XG5cbiAgaWYgKHNlbGVjdGRFbGVtZW50LmlzRW1wdHkoKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHNlbGVjdGVkRG9tRWxlbWVudCA9IGdldE5vZGVGb3JFbGVtZW50S2V5KHNlbGVjdGRFbGVtZW50LmdldEtleSgpKTtcblxuICBpZiAoIXNlbGVjdGVkRG9tRWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHBhcmVudFBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgIGlkOiBtZXNzYWdlSWQsXG4gICAgbWF0Y2hlczogc2VsZWN0ZWREb21FbGVtZW50Py5tYXRjaGVzKHJ1bGUpLFxuICB9KTtcbn07XG4iXX0=