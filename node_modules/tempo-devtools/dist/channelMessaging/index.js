"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.initChannelMessaging = void 0;
// KEEP THIS IN SYNC WITH sessionStorageUtils.*.tsx
const resqUtils_1 = require("./resqUtils");
const lz_string_1 = __importDefault(require("lz-string"));
const posthog_js_1 = __importDefault(require("../posthog.js"));
const channelMessagingFunctions_1 = require("./channelMessagingFunctions");
// For vite only, show errors in the browser
if (typeof window !== 'undefined' &&
    window.location.href.includes('framework=VITE')) {
    const showErrorOverlay = (err) => {
        // must be within function call because that's when the element is defined for sure.
        const ErrorOverlay = customElements.get('vite-error-overlay');
        // don't open outside vite environment
        if (!ErrorOverlay) {
            return;
        }
        const overlay = new ErrorOverlay(err);
        document.body.appendChild(overlay);
    };
    window.addEventListener('error', showErrorOverlay);
    window.addEventListener('unhandledrejection', ({ reason }) => showErrorOverlay(reason));
}
const debugLogInDev = (...str) => {
    var _a;
    // Only in dev
    if ((_a = window.location.search) === null || _a === void 0 ? void 0 : _a.includes('debugLog=true')) {
        console.debug(...str);
    }
};
function initChannelMessaging() {
    var _a;
    (0, channelMessagingFunctions_1.initChannelMessagingFunctions)();
    // Only in prod
    if (window.location.hostname.endsWith('dev.tempolabs.ai') &&
        !window.location.hostname.endsWith('staging-dev.tempolabs.ai')) {
        if (posthog_js_1.default) {
            posthog_js_1.default.init();
        }
    }
    window.addEventListener('message', (event) => {
        const { data } = event;
        if (data.type === 'GET_STATE_AND_PROPS') {
            const { componentName } = data;
            // TODO: Support custom root that user provides
            let rootSelector = '#root';
            if (!document.querySelector(rootSelector)) {
                rootSelector = '#__next';
            }
            const rootReactElement = (0, resqUtils_1.getRootReactElement)();
            const tree = (0, resqUtils_1.buildNodeTree)(rootReactElement, null);
            const foundNodes = (0, resqUtils_1.findElementInTree)(tree, (node) => {
                if (componentName && node.name == componentName) {
                    return true;
                }
                return false;
            });
            if (!(foundNodes === null || foundNodes === void 0 ? void 0 : foundNodes.length)) {
                const message = {
                    error: 'No component found',
                };
                console.log('STATE_AND_PROPS ', JSON.stringify(message));
                return;
            }
            if (foundNodes.length > 1) {
                console.log(foundNodes);
                console.log('Warning: more than 1 component found');
            }
            const foundNode = foundNodes[0];
            const sendDataForNode = (node) => {
                debugLogInDev('NODE FOUND: ', node);
                const PROPS_TO_EXCLUDE = {
                    tempoelementid: true,
                    'data-testid': true,
                };
                const propsToSend = {};
                if (node.props) {
                    Object.keys(node.props).forEach((key) => {
                        if (!PROPS_TO_EXCLUDE[key]) {
                            if (typeof node.props[key] === 'object') {
                                propsToSend[key] = 'TEMPO_OBJECT_TYPE';
                            }
                            else if (typeof node.props[key] === 'function') {
                                propsToSend[key] = 'TEMPO_FUNCTION_TYPE';
                            }
                            else {
                                propsToSend[key] = node.props[key];
                            }
                        }
                    });
                }
                // TODO: This doesn't fully work because of this bug: https://github.com/baruchvlz/resq/issues/85
                let stateToSend = {};
                if (node.state) {
                    if (typeof node.state === 'string') {
                        stateToSend = {
                            state: node.state,
                        };
                    }
                    else {
                        Object.keys(node.state).forEach((key) => {
                            if (typeof node.state[key] === 'object') {
                                stateToSend[key] = 'TEMPO_OBJECT_TYPE';
                            }
                            else if (typeof node.state[key] === 'function') {
                                stateToSend[key] = 'TEMPO_FUNCTION_TYPE';
                            }
                            else {
                                stateToSend[key] = node.state[key];
                            }
                        });
                    }
                }
                const message = {
                    id: data.id,
                    props: propsToSend,
                    state: stateToSend,
                };
                console.log('STATE_AND_PROPS ', JSON.stringify(message));
            };
            sendDataForNode(foundNode);
        }
    });
    if ((_a = window.location.search) === null || _a === void 0 ? void 0 : _a.includes('storyboard=true')) {
        let rootEl = document.getElementById('root');
        if (!rootEl) {
            rootEl = document.getElementById('__next');
        }
        if (rootEl) {
            if (window.location.search.includes('type=STORY') ||
                window.location.search.includes('type=COMPONENT')) {
                [rootEl, document.body, document.documentElement].forEach((el) => {
                    el.style.backgroundColor = 'transparent';
                    el.style.width = '100vw';
                    el.style.height = '100vh';
                    el.style.overflow = 'hidden';
                });
            }
            else {
                rootEl.style.width = '100vw';
                rootEl.style.height = '100vh';
            }
        }
    }
    (function () {
        let port2 = null;
        let storyboardId = null;
        // Setup the transfered port
        const initPort = (e) => {
            if (e.data === 'init') {
                port2 = e.ports[0];
                port2.onmessage = onMessage;
            }
            else {
                var msgObj = e.data;
                onMessage({
                    data: msgObj,
                });
            }
        };
        // Listen for the intial port transfer message
        window.addEventListener('message', initPort);
        const onInspectElement = (data) => __awaiter(this, void 0, void 0, function* () {
            if (!data.payload.componentName) {
                console.log('NO COMPONENT NAME');
                const message = {
                    id: data.id,
                    error: 'No component name',
                };
                port2 === null || port2 === void 0 ? void 0 : port2.postMessage(message);
                return;
            }
            // TODO: Support custom root that user provides
            const rootReactElement = (0, resqUtils_1.getRootReactElement)();
            const tree = (0, resqUtils_1.buildNodeTree)(rootReactElement, null);
            const { isComponent, componentName, tempoElementID, componentElementId, } = data.payload;
            if (!isComponent && !tempoElementID) {
                console.log('No tempo element ID provided');
                const message = {
                    id: data.id,
                    error: 'Could not find element',
                };
                port2 === null || port2 === void 0 ? void 0 : port2.postMessage(message);
                return;
            }
            if (isComponent && !tempoElementID && !componentName) {
                console.log('No tempo element ID or component name provided');
                const message = {
                    id: data.id,
                    error: 'Could not find component',
                };
                port2 === null || port2 === void 0 ? void 0 : port2.postMessage(message);
                return;
            }
            const foundNodes = (0, resqUtils_1.findElementInTree)(tree, (node) => {
                var _a, _b, _c, _d, _e, _f;
                if (isComponent) {
                    // Check tempoElementID, and if it's not provided, use the component name
                    if (tempoElementID &&
                        (((_a = node.props) === null || _a === void 0 ? void 0 : _a.tempoelementid) == tempoElementID ||
                            ((_b = node.props) === null || _b === void 0 ? void 0 : _b['data-testid']) == tempoElementID)) {
                        return true;
                    }
                    if (!tempoElementID &&
                        componentName &&
                        node.name == componentName) {
                        return true;
                    }
                }
                else {
                    // The tempo element ID must always match
                    if (tempoElementID &&
                        ((_c = node.props) === null || _c === void 0 ? void 0 : _c.tempoelementid) !== tempoElementID &&
                        ((_d = node.props) === null || _d === void 0 ? void 0 : _d['data-testid']) !== tempoElementID) {
                        return false;
                    }
                    // If the component instance ID is provided, go up the chain to check if there are any parents with this component instance ID set
                    if (componentElementId) {
                        let nodeToCheck = node.parent;
                        let foundMatchingComponent = false;
                        while (nodeToCheck) {
                            if (((_e = nodeToCheck.props) === null || _e === void 0 ? void 0 : _e.tempoelementid) === componentElementId ||
                                ((_f = nodeToCheck.props) === null || _f === void 0 ? void 0 : _f['data-testid']) === componentElementId) {
                                foundMatchingComponent = true;
                                break;
                            }
                            nodeToCheck = nodeToCheck.parent;
                        }
                        if (!foundMatchingComponent) {
                            return false;
                        }
                    }
                    return true;
                }
                return false;
            });
            if (!(foundNodes === null || foundNodes === void 0 ? void 0 : foundNodes.length)) {
                debugLogInDev('NO COMPONENT FOUND');
                const message = {
                    id: data.id,
                    error: 'No component found',
                };
                port2 === null || port2 === void 0 ? void 0 : port2.postMessage(message);
                return;
            }
            if (foundNodes.length > 1) {
                console.log(foundNodes);
                console.log('Warning: more than 1 component found');
            }
            const foundNode = foundNodes[0];
            const sendDataForNode = (node) => {
                debugLogInDev('NODE FOUND: ', node);
                const propsToSend = {};
                if (node.props) {
                    Object.keys(node.props).forEach((key) => {
                        if (typeof node.props[key] === 'object') {
                            propsToSend[key] = 'TEMPO_OBJECT_TYPE';
                        }
                        else if (typeof node.props[key] === 'function') {
                            propsToSend[key] = 'TEMPO_FUNCTION_TYPE';
                        }
                        else {
                            propsToSend[key] = node.props[key];
                        }
                    });
                }
                // TODO: This doesn't fully work because of this bug: https://github.com/baruchvlz/resq/issues/85
                let stateToSend = {};
                if (node.state) {
                    if (typeof node.state === 'string') {
                        stateToSend = {
                            state: node.state,
                        };
                    }
                    else {
                        Object.keys(node.state).forEach((key) => {
                            if (typeof node.state[key] === 'object') {
                                stateToSend[key] = 'TEMPO_OBJECT_TYPE';
                            }
                            else if (typeof node.state[key] === 'function') {
                                stateToSend[key] = 'TEMPO_FUNCTION_TYPE';
                            }
                            else {
                                stateToSend[key] = node.state[key];
                            }
                        });
                    }
                }
                const message = {
                    id: data.id,
                    props: propsToSend,
                    state: stateToSend,
                };
                debugLogInDev('RESPONDING WITH: ', message);
                port2 === null || port2 === void 0 ? void 0 : port2.postMessage(message);
            };
            sendDataForNode(foundNode);
        });
        // Handle messages received on port2
        const onMessage = (e) => __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            try {
                const data = e.data;
                const dataToLog = Object.assign({}, data);
                if ((_a = data === null || data === void 0 ? void 0 : data.payload) === null || _a === void 0 ? void 0 : _a.compressedArgs) {
                    dataToLog.payload = Object.assign(Object.assign({}, data.payload), { compressedArgs: 'COMPRESSED' });
                }
                // These contain args that are too large to log
                const LOGS_TO_SKIP_ARGS = [
                    'initProject',
                    'setNewLookups',
                    'processRulesForSelectedElement',
                ];
                if (((_b = data === null || data === void 0 ? void 0 : data.payload) === null || _b === void 0 ? void 0 : _b.functionName) &&
                    LOGS_TO_SKIP_ARGS.includes(data.payload.functionName)) {
                    dataToLog.payload = Object.assign(Object.assign({}, data.payload), { args: 'ARGS_SKIPPED' });
                }
                debugLogInDev('INNER FRAME: Received message from parent: ', JSON.stringify(dataToLog));
                if (!data || !data.payload) {
                    debugLogInDev('NO PAYLOAD');
                    return;
                }
                if (!data.id) {
                    debugLogInDev('NO ID');
                    return;
                }
                if (data.type === 'inspectElement') {
                    onInspectElement(data);
                }
                else if (data.type === 'executeFunction') {
                    const fn = window[data.payload.functionName];
                    if (typeof fn === 'function') {
                        // Special case to register the storyboardId
                        let args = data.payload.args;
                        if (data.payload.compressedArgs) {
                            args = JSON.parse(lz_string_1.default.decompress(data.payload.compressedArgs));
                        }
                        if (data.payload.functionName === 'initProject') {
                            storyboardId = args[0];
                            args = args.slice(1);
                        }
                        if (data.payload.args) {
                            // @ts-ignore
                            const result = fn(port2, storyboardId, ...args);
                            if (result instanceof Promise) {
                                yield result;
                            }
                        }
                        else {
                            // @ts-ignore
                            const result = fn(port2, storyboardId);
                            if (result instanceof Promise) {
                                yield result;
                            }
                        }
                    }
                    else {
                        console.log('INNER FRAME ERROR: Function to execute not found');
                    }
                }
            }
            catch (error) {
                console.log('INNER FRAME ERROR: ', error);
                // TODO: Send error back to parent?
            }
        });
    })();
}
exports.initChannelMessaging = initChannelMessaging;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvY2hhbm5lbE1lc3NhZ2luZy9pbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQSxtREFBbUQ7QUFDbkQsMkNBSXFCO0FBRXJCLDBEQUEyQjtBQUMzQiwrREFBb0M7QUFFcEMsMkVBQTRFO0FBRTVFLDRDQUE0QztBQUM1QyxJQUNFLE9BQU8sTUFBTSxLQUFLLFdBQVc7SUFDN0IsTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLGdCQUFnQixDQUFDLEVBQy9DO0lBQ0EsTUFBTSxnQkFBZ0IsR0FBRyxDQUFDLEdBQVEsRUFBRSxFQUFFO1FBQ3BDLG9GQUFvRjtRQUNwRixNQUFNLFlBQVksR0FBRyxjQUFjLENBQUMsR0FBRyxDQUFDLG9CQUFvQixDQUFDLENBQUM7UUFDOUQsc0NBQXNDO1FBQ3RDLElBQUksQ0FBQyxZQUFZLEVBQUU7WUFDakIsT0FBTztTQUNSO1FBQ0QsTUFBTSxPQUFPLEdBQUcsSUFBSSxZQUFZLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDdEMsUUFBUSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDckMsQ0FBQyxDQUFDO0lBRUYsTUFBTSxDQUFDLGdCQUFnQixDQUFDLE9BQU8sRUFBRSxnQkFBZ0IsQ0FBQyxDQUFDO0lBQ25ELE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxvQkFBb0IsRUFBRSxDQUFDLEVBQUUsTUFBTSxFQUFFLEVBQUUsRUFBRSxDQUMzRCxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsQ0FDekIsQ0FBQztDQUNIO0FBRUQsTUFBTSxhQUFhLEdBQUcsQ0FBQyxHQUFHLEdBQVUsRUFBRSxFQUFFOztJQUN0QyxjQUFjO0lBQ2QsSUFBSSxNQUFBLE1BQU0sQ0FBQyxRQUFRLENBQUMsTUFBTSwwQ0FBRSxRQUFRLENBQUMsZUFBZSxDQUFDLEVBQUU7UUFDckQsT0FBTyxD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QUFVLEVBQUU7Z0JBQ25CLE9BQU8sQ0FBQyxHQUFHLENBQUMscUJBQXFCLEVBQUUsS0FBSyxDQUFDLENBQUM7Z0JBQzFDLG1DQUFtQzthQUNwQztRQUNILENBQUMsQ0FBQSxDQUFDO0lBQ0osQ0FBQyxDQUFDLEVBQUUsQ0FBQztBQUNQLENBQUM7QUF6WUQsb0RBeVlDIiwic291cmNlc0NvbnRlbnQiOlsiLy8gS0VFUCBUSElTIElOIFNZTkMgV0lUSCBzZXNzaW9uU3RvcmFnZVV0aWxzLioudHN4XG5pbXBvcnQge1xuICBidWlsZE5vZGVUcmVlLFxuICBmaW5kRWxlbWVudEluVHJlZSxcbiAgZ2V0Um9vdFJlYWN0RWxlbWVudCxcbn0gZnJvbSAnLi9yZXNxVXRpbHMnO1xuXG5pbXBvcnQgbHogZnJvbSAnbHotc3RyaW5nJztcbmltcG9ydCBQb3N0aG9nIGZyb20gJy4uL3Bvc3Rob2cuanMnO1xuXG5pbXBvcnQgeyBpbml0Q2hhbm5lbE1lc3NhZ2luZ0Z1bmN0aW9ucyB9IGZyb20gJy4vY2hhbm5lbE1lc3NhZ2luZ0Z1bmN0aW9ucyc7XG5cbi8vIEZvciB2aXRlIG9ubHksIHNob3cgZXJyb3JzIGluIHRoZSBicm93c2VyXG5pZiAoXG4gIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gIHdpbmRvdy5sb2NhdGlvbi5ocmVmLmluY2x1ZGVzKCdmcmFtZXdvcms9VklURScpXG4pIHtcbiAgY29uc3Qgc2hvd0Vycm9yT3ZlcmxheSA9IChlcnI6IGFueSkgPT4ge1xuICAgIC8vIG11c3QgYmUgd2l0aGluIGZ1bmN0aW9uIGNhbGwgYmVjYXVzZSB0aGF0J3Mgd2hlbiB0aGUgZWxlbWVudCBpcyBkZWZpbmVkIGZvciBzdXJlLlxuICAgIGNvbnN0IEVycm9yT3ZlcmxheSA9IGN1c3RvbUVsZW1lbnRzLmdldCgndml0ZS1lcnJvci1vdmVybGF5Jyk7XG4gICAgLy8gZG9uJ3Qgb3BlbiBvdXRzaWRlIHZpdGUgZW52aXJvbm1lbnRcbiAgICBpZiAoIUVycm9yT3ZlcmxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBvdmVybGF5ID0gbmV3IEVycm9yT3ZlcmxheShlcnIpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQob3ZlcmxheSk7XG4gIH07XG5cbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgc2hvd0Vycm9yT3ZlcmxheSk7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd1bmhhbmRsZWRyZWplY3Rpb24nLCAoeyByZWFzb24gfSkgPT5cbiAgICBzaG93RXJyb3JPdmVybGF5KHJlYXNvbiksXG4gICk7XG59XG5cbmNvbnN0IGRlYnVnTG9nSW5EZXYgPSAoLi4uc3RyOiBhbnlbXSkgPT4ge1xuICAvLyBPbmx5IGluIGRldlxuICBpZiAod2luZG93LmxvY2F0aW9uLnNlYXJjaD8uaW5jbHVkZXMoJ2RlYnVnTG9nPXRydWUnKSkge1xuICAgIGNvbnNvbGUuZGVidWcoLi4uc3RyKTtcbiAgfVxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGluaXRDaGFubmVsTWVzc2FnaW5nKCkge1xuICBpbml0Q2hhbm5lbE1lc3NhZ2luZ0Z1bmN0aW9ucygpO1xuXG4gIC8vIE9ubHkgaW4gcHJvZFxuICBpZiAoXG4gICAgd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lLmVuZHNXaXRoKCdkZXYudGVtcG9sYWJzLmFpJykgJiZcbiAgICAhd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lLmVuZHNXaXRoKCdzdGFnaW5nLWRldi50ZW1wb2xhYnMuYWknKVxuICApIHtcbiAgICBpZiAoUG9zdGhvZykge1xuICAgICAgUG9zdGhvZy5pbml0KCk7XG4gICAgfVxuXG4gIH1cbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCAoZXZlbnQpID0+IHtcbiAgICBjb25zdCB7IGRhdGEgfSA9IGV2ZW50O1xuICAgIGlmIChkYXRhLnR5cGUgPT09ICdHRVRfU1RBVEVfQU5EX1BST1BTJykge1xuICAgICAgY29uc3QgeyBjb21wb25lbnROYW1lIH0gPSBkYXRhO1xuXG4gICAgICAvLyBUT0RPOiBTdXBwb3J0IGN1c3RvbSByb290IHRoYXQgdXNlciBwcm92aWRlc1xuICAgICAgbGV0IHJvb3RTZWxlY3RvciA9ICcjcm9vdCc7XG4gICAgICBpZiAoIWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Iocm9vdFNlbGVjdG9yKSkge1xuICAgICAgICByb290U2VsZWN0b3IgPSAnI19fbmV4dCc7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJvb3RSZWFjdEVsZW1lbnQgPSBnZXRSb290UmVhY3RFbGVtZW50KCk7XG5cbiAgICAgIGNvbnN0IHRyZWUgPSBidWlsZE5vZGVUcmVlKHJvb3RSZWFjdEVsZW1lbnQsIG51bGwpO1xuXG4gICAgICBjb25zdCBmb3VuZE5vZGVzID0gZmluZEVsZW1lbnRJblRyZWUodHJlZSwgKG5vZGU6IGFueSkgPT4ge1xuICAgICAgICBpZiAoY29tcG9uZW50TmFtZSAmJiBub2RlLm5hbWUgPT0gY29tcG9uZW50TmFtZSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIWZvdW5kTm9kZXM/Lmxlbmd0aCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0ge1xuICAgICAgICAgIGVycm9yOiAnTm8gY29tcG9uZW50IGZvdW5kJyxcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zb2xlLmxvZygnU1RBVEVfQU5EX1BST1BTICcsIEpTT04uc3RyaW5naWZ5KG1lc3NhZ2UpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZm91bmROb2Rlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGZvdW5kTm9kZXMpO1xuICAgICAgICBjb25zb2xlLmxvZygnV2FybmluZzogbW9yZSB0aGFuIDEgY29tcG9uZW50IGZvdW5kJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZvdW5kTm9kZSA9IGZvdW5kTm9kZXNbMF07XG5cbiAgICAgIGNvbnN0IHNlbmREYXRhRm9yTm9kZSA9IChub2RlOiBhbnkpID0+IHtcbiAgICAgICAgZGVidWdMb2dJbkRldignTk9ERSBGT1VORDogJywgbm9kZSk7XG5cbiAgICAgICAgY29uc3QgUFJPUFNfVE9fRVhDTFVERTogYW55ID0ge1xuICAgICAgICAgIHRlbXBvZWxlbWVudGlkOiB0cnVlLFxuICAgICAgICAgICdkYXRhLXRlc3RpZCc6IHRydWUsXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgcHJvcHNUb1NlbmQ6IGFueSA9IHt9O1xuICAgICAgICBpZiAobm9kZS5wcm9wcykge1xuICAgICAgICAgIE9iamVjdC5rZXlzKG5vZGUucHJvcHMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFQUk9QU19UT19FWENMVURFW2tleV0pIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBub2RlLnByb3BzW2tleV0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgcHJvcHNUb1NlbmRba2V5XSA9ICdURU1QT19PQkpFQ1RfVFlQRSc7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5vZGUucHJvcHNba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHByb3BzVG9TZW5kW2tleV0gPSAnVEVNUE9fRlVOQ1RJT05fVFlQRSc7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvcHNUb1NlbmRba2V5XSA9IG5vZGUucHJvcHNba2V5XTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogVGhpcyBkb2Vzbid0IGZ1bGx5IHdvcmsgYmVjYXVzZSBvZiB0aGlzIGJ1ZzogaHR0cHM6Ly9naXRodWIuY29tL2JhcnVjaHZsei9yZXNxL2lzc3Vlcy84NVxuICAgICAgICBsZXQgc3RhdGVUb1NlbmQ6IGFueSA9IHt9O1xuICAgICAgICBpZiAobm9kZS5zdGF0ZSkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygbm9kZS5zdGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHN0YXRlVG9TZW5kID0ge1xuICAgICAgICAgICAgICBzdGF0ZTogbm9kZS5zdGF0ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKG5vZGUuc3RhdGUpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIG5vZGUuc3RhdGVba2V5XSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZVRvU2VuZFtrZXldID0gJ1RFTVBPX09CSkVDVF9UWVBFJztcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygbm9kZS5zdGF0ZVtrZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVUb1NlbmRba2V5XSA9ICdURU1QT19GVU5DVElPTl9UWVBFJztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGF0ZVRvU2VuZFtrZXldID0gbm9kZS5zdGF0ZVtrZXldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBtZXNzYWdlID0ge1xuICAgICAgICAgIGlkOiBkYXRhLmlkLFxuICAgICAgICAgIHByb3BzOiBwcm9wc1RvU2VuZCxcbiAgICAgICAgICBzdGF0ZTogc3RhdGVUb1NlbmQsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnNvbGUubG9nKCdTVEFURV9BTkRfUFJPUFMgJywgSlNPTi5zdHJpbmdpZnkobWVzc2FnZSkpO1xuICAgICAgfTtcblxuICAgICAgc2VuZERhdGFGb3JOb2RlKGZvdW5kTm9kZSk7XG4gICAgfVxuICB9KTtcblxuICBpZiAod2luZG93LmxvY2F0aW9uLnNlYXJjaD8uaW5jbHVkZXMoJ3N0b3J5Ym9hcmQ9dHJ1ZScpKSB7XG4gICAgbGV0IHJvb3RFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyb290Jyk7XG4gICAgaWYgKCFyb290RWwpIHtcbiAgICAgIHJvb3RFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdfX25leHQnKTtcbiAgICB9XG5cbiAgICBpZiAocm9vdEVsKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5zZWFyY2guaW5jbHVkZXMoJ3R5cGU9U1RPUlknKSB8fFxuICAgICAgICB3aW5kb3cubG9jYXRpb24uc2VhcmNoLmluY2x1ZGVzKCd0eXBlPUNPTVBPTkVOVCcpXG4gICAgICApIHtcbiAgICAgICAgW3Jvb3RFbCwgZG9jdW1lbnQuYm9keSwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XS5mb3JFYWNoKChlbCkgPT4ge1xuICAgICAgICAgIGVsLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICd0cmFuc3BhcmVudCc7XG4gICAgICAgICAgZWwuc3R5bGUud2lkdGggPSAnMTAwdncnO1xuICAgICAgICAgIGVsLnN0eWxlLmhlaWdodCA9ICcxMDB2aCc7XG4gICAgICAgICAgZWwuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb290RWwuc3R5bGUud2lkdGggPSAnMTAwdncnO1xuICAgICAgICByb290RWwuc3R5bGUuaGVpZ2h0ID0gJzEwMHZoJztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAoZnVuY3Rpb24gKCkge1xuICAgIGxldCBwb3J0MjogTWVzc2FnZVBvcnQgfCBudWxsID0gbnVsbDtcbiAgICBsZXQgc3Rvcnlib2FyZElkOiBhbnkgPSBudWxsO1xuXG4gICAgLy8gU2V0dXAgdGhlIHRyYW5zZmVyZWQgcG9ydFxuICAgIGNvbnN0IGluaXRQb3J0ID0gKGU6IE1lc3NhZ2VFdmVudCkgPT4ge1xuICAgICAgaWYgKGUuZGF0YSA9PT0gJ2luaXQnKSB7XG4gICAgICAgIHBvcnQyID0gZS5wb3J0c1swXTtcbiAgICAgICAgcG9ydDIub25tZXNzYWdlID0gb25NZXNzYWdlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG1zZ09iaiA9IGUuZGF0YTtcbiAgICAgICAgb25NZXNzYWdlKHtcbiAgICAgICAgICBkYXRhOiBtc2dPYmosXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBMaXN0ZW4gZm9yIHRoZSBpbnRpYWwgcG9ydCB0cmFuc2ZlciBtZXNzYWdlXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBpbml0UG9ydCk7XG5cbiAgICBjb25zdCBvbkluc3BlY3RFbGVtZW50ID0gYXN5bmMgKGRhdGE6IGFueSkgPT4ge1xuICAgICAgaWYgKCFkYXRhLnBheWxvYWQuY29tcG9uZW50TmFtZSkge1xuICAgICAgICBjb25zb2xlLmxvZygnTk8gQ09NUE9ORU5UIE5BTUUnKTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IHtcbiAgICAgICAgICBpZDogZGF0YS5pZCxcbiAgICAgICAgICBlcnJvcjogJ05vIGNvbXBvbmVudCBuYW1lJyxcbiAgICAgICAgfTtcbiAgICAgICAgcG9ydDI/LnBvc3RNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFRPRE86IFN1cHBvcnQgY3VzdG9tIHJvb3QgdGhhdCB1c2VyIHByb3ZpZGVzXG4gICAgICBjb25zdCByb290UmVhY3RFbGVtZW50ID0gZ2V0Um9vdFJlYWN0RWxlbWVudCgpO1xuICAgICAgY29uc3QgdHJlZSA9IGJ1aWxkTm9kZVRyZWUocm9vdFJlYWN0RWxlbWVudCwgbnVsbCk7XG5cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaXNDb21wb25lbnQsXG4gICAgICAgIGNvbXBvbmVudE5hbWUsXG4gICAgICAgIHRlbXBvRWxlbWVudElELFxuICAgICAgICBjb21wb25lbnRFbGVtZW50SWQsXG4gICAgICB9ID0gZGF0YS5wYXlsb2FkO1xuXG4gICAgICBpZiAoIWlzQ29tcG9uZW50ICYmICF0ZW1wb0VsZW1lbnRJRCkge1xuICAgICAgICBjb25zb2xlLmxvZygnTm8gdGVtcG8gZWxlbWVudCBJRCBwcm92aWRlZCcpO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0ge1xuICAgICAgICAgIGlkOiBkYXRhLmlkLFxuICAgICAgICAgIGVycm9yOiAnQ291bGQgbm90IGZpbmQgZWxlbWVudCcsXG4gICAgICAgIH07XG4gICAgICAgIHBvcnQyPy5wb3N0TWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNDb21wb25lbnQgJiYgIXRlbXBvRWxlbWVudElEICYmICFjb21wb25lbnROYW1lKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdObyB0ZW1wbyBlbGVtZW50IElEIG9yIGNvbXBvbmVudCBuYW1lIHByb3ZpZGVkJyk7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB7XG4gICAgICAgICAgaWQ6IGRhdGEuaWQsXG4gICAgICAgICAgZXJyb3I6ICdDb3VsZCBub3QgZmluZCBjb21wb25lbnQnLFxuICAgICAgICB9O1xuICAgICAgICBwb3J0Mj8ucG9zdE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZm91bmROb2RlcyA9IGZpbmRFbGVtZW50SW5UcmVlKHRyZWUsIChub2RlOiBhbnkpID0+IHtcbiAgICAgICAgaWYgKGlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgLy8gQ2hlY2sgdGVtcG9FbGVtZW50SUQsIGFuZCBpZiBpdCdzIG5vdCBwcm92aWRlZCwgdXNlIHRoZSBjb21wb25lbnQgbmFtZVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHRlbXBvRWxlbWVudElEICYmXG4gICAgICAgICAgICAobm9kZS5wcm9wcz8udGVtcG9lbGVtZW50aWQgPT0gdGVtcG9FbGVtZW50SUQgfHxcbiAgICAgICAgICAgICAgbm9kZS5wcm9wcz8uWydkYXRhLXRlc3RpZCddID09IHRlbXBvRWxlbWVudElEKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIXRlbXBvRWxlbWVudElEICYmXG4gICAgICAgICAgICBjb21wb25lbnROYW1lICYmXG4gICAgICAgICAgICBub2RlLm5hbWUgPT0gY29tcG9uZW50TmFtZVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRoZSB0ZW1wbyBlbGVtZW50IElEIG11c3QgYWx3YXlzIG1hdGNoXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGVtcG9FbGVtZW50SUQgJiZcbiAgICAgICAgICAgIG5vZGUucHJvcHM/LnRlbXBvZWxlbWVudGlkICE9PSB0ZW1wb0VsZW1lbnRJRCAmJlxuICAgICAgICAgICAgbm9kZS5wcm9wcz8uWydkYXRhLXRlc3RpZCddICE9PSB0ZW1wb0VsZW1lbnRJRFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIHRoZSBjb21wb25lbnQgaW5zdGFuY2UgSUQgaXMgcHJvdmlkZWQsIGdvIHVwIHRoZSBjaGFpbiB0byBjaGVjayBpZiB0aGVyZSBhcmUgYW55IHBhcmVudHMgd2l0aCB0aGlzIGNvbXBvbmVudCBpbnN0YW5jZSBJRCBzZXRcbiAgICAgICAgICBpZiAoY29tcG9uZW50RWxlbWVudElkKSB7XG4gICAgICAgICAgICBsZXQgbm9kZVRvQ2hlY2sgPSBub2RlLnBhcmVudDtcbiAgICAgICAgICAgIGxldCBmb3VuZE1hdGNoaW5nQ29tcG9uZW50ID0gZmFsc2U7XG4gICAgICAgICAgICB3aGlsZSAobm9kZVRvQ2hlY2spIHtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIG5vZGVUb0NoZWNrLnByb3BzPy50ZW1wb2VsZW1lbnRpZCA9PT0gY29tcG9uZW50RWxlbWVudElkIHx8XG4gICAgICAgICAgICAgICAgbm9kZVRvQ2hlY2sucHJvcHM/LlsnZGF0YS10ZXN0aWQnXSA9PT0gY29tcG9uZW50RWxlbWVudElkXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGZvdW5kTWF0Y2hpbmdDb21wb25lbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG5vZGVUb0NoZWNrID0gbm9kZVRvQ2hlY2sucGFyZW50O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWZvdW5kTWF0Y2hpbmdDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSk7XG5cbiAgICAgIGlmICghZm91bmROb2Rlcz8ubGVuZ3RoKSB7XG4gICAgICAgIGRlYnVnTG9nSW5EZXYoJ05PIENPTVBPTkVOVCBGT1VORCcpO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0ge1xuICAgICAgICAgIGlkOiBkYXRhLmlkLFxuICAgICAgICAgIGVycm9yOiAnTm8gY29tcG9uZW50IGZvdW5kJyxcbiAgICAgICAgfTtcbiAgICAgICAgcG9ydDI/LnBvc3RNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChmb3VuZE5vZGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgY29uc29sZS5sb2coZm91bmROb2Rlcyk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdXYXJuaW5nOiBtb3JlIHRoYW4gMSBjb21wb25lbnQgZm91bmQnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZm91bmROb2RlID0gZm91bmROb2Rlc1swXTtcblxuICAgICAgY29uc3Qgc2VuZERhdGFGb3JOb2RlID0gKG5vZGU6IGFueSkgPT4ge1xuICAgICAgICBkZWJ1Z0xvZ0luRGV2KCdOT0RFIEZPVU5EOiAnLCBub2RlKTtcblxuICAgICAgICBjb25zdCBwcm9wc1RvU2VuZDogYW55ID0ge307XG4gICAgICAgIGlmIChub2RlLnByb3BzKSB7XG4gICAgICAgICAgT2JqZWN0LmtleXMobm9kZS5wcm9wcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5vZGUucHJvcHNba2V5XSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgcHJvcHNUb1NlbmRba2V5XSA9ICdURU1QT19PQkpFQ1RfVFlQRSc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBub2RlLnByb3BzW2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgcHJvcHNUb1NlbmRba2V5XSA9ICdURU1QT19GVU5DVElPTl9UWVBFJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHByb3BzVG9TZW5kW2tleV0gPSBub2RlLnByb3BzW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiBUaGlzIGRvZXNuJ3QgZnVsbHkgd29yayBiZWNhdXNlIG9mIHRoaXMgYnVnOiBodHRwczovL2dpdGh1Yi5jb20vYmFydWNodmx6L3Jlc3EvaXNzdWVzLzg1XG4gICAgICAgIGxldCBzdGF0ZVRvU2VuZDogYW55ID0ge307XG4gICAgICAgIGlmIChub2RlLnN0YXRlKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBub2RlLnN0YXRlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgc3RhdGVUb1NlbmQgPSB7XG4gICAgICAgICAgICAgIHN0YXRlOiBub2RlLnN0YXRlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMobm9kZS5zdGF0ZSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2Ygbm9kZS5zdGF0ZVtrZXldID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHN0YXRlVG9TZW5kW2tleV0gPSAnVEVNUE9fT0JKRUNUX1RZUEUnO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBub2RlLnN0YXRlW2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZVRvU2VuZFtrZXldID0gJ1RFTVBPX0ZVTkNUSU9OX1RZUEUnO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXRlVG9TZW5kW2tleV0gPSBub2RlLnN0YXRlW2tleV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB7XG4gICAgICAgICAgaWQ6IGRhdGEuaWQsXG4gICAgICAgICAgcHJvcHM6IHByb3BzVG9TZW5kLFxuICAgICAgICAgIHN0YXRlOiBzdGF0ZVRvU2VuZCxcbiAgICAgICAgfTtcbiAgICAgICAgZGVidWdMb2dJbkRldignUkVTUE9ORElORyBXSVRIOiAnLCBtZXNzYWdlKTtcblxuICAgICAgICBwb3J0Mj8ucG9zdE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICB9O1xuXG4gICAgICBzZW5kRGF0YUZvck5vZGUoZm91bmROb2RlKTtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIG1lc3NhZ2VzIHJlY2VpdmVkIG9uIHBvcnQyXG4gICAgY29uc3Qgb25NZXNzYWdlID0gYXN5bmMgKGU6IGFueSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGUuZGF0YTtcbiAgICAgICAgY29uc3QgZGF0YVRvTG9nID0geyAuLi5kYXRhIH07XG4gICAgICAgIGlmIChkYXRhPy5wYXlsb2FkPy5jb21wcmVzc2VkQXJncykge1xuICAgICAgICAgIGRhdGFUb0xvZy5wYXlsb2FkID0ge1xuICAgICAgICAgICAgLi4uZGF0YS5wYXlsb2FkLFxuICAgICAgICAgICAgY29tcHJlc3NlZEFyZ3M6ICdDT01QUkVTU0VEJyxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZXNlIGNvbnRhaW4gYXJncyB0aGF0IGFyZSB0b28gbGFyZ2UgdG8gbG9nXG4gICAgICAgIGNvbnN0IExPR1NfVE9fU0tJUF9BUkdTID0gW1xuICAgICAgICAgICdpbml0UHJvamVjdCcsXG4gICAgICAgICAgJ3NldE5ld0xvb2t1cHMnLFxuICAgICAgICAgICdwcm9jZXNzUnVsZXNGb3JTZWxlY3RlZEVsZW1lbnQnLFxuICAgICAgICBdO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgZGF0YT8ucGF5bG9hZD8uZnVuY3Rpb25OYW1lICYmXG4gICAgICAgICAgTE9HU19UT19TS0lQX0FSR1MuaW5jbHVkZXMoZGF0YS5wYXlsb2FkLmZ1bmN0aW9uTmFtZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgZGF0YVRvTG9nLnBheWxvYWQgPSB7XG4gICAgICAgICAgICAuLi5kYXRhLnBheWxvYWQsXG4gICAgICAgICAgICBhcmdzOiAnQVJHU19TS0lQUEVEJyxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgZGVidWdMb2dJbkRldihcbiAgICAgICAgICAnSU5ORVIgRlJBTUU6IFJlY2VpdmVkIG1lc3NhZ2UgZnJvbSBwYXJlbnQ6ICcsXG4gICAgICAgICAgSlNPTi5zdHJpbmdpZnkoZGF0YVRvTG9nKSxcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoIWRhdGEgfHwgIWRhdGEucGF5bG9hZCkge1xuICAgICAgICAgIGRlYnVnTG9nSW5EZXYoJ05PIFBBWUxPQUQnKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWRhdGEuaWQpIHtcbiAgICAgICAgICBkZWJ1Z0xvZ0luRGV2KCdOTyBJRCcpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRhLnR5cGUgPT09ICdpbnNwZWN0RWxlbWVudCcpIHtcbiAgICAgICAgICBvbkluc3BlY3RFbGVtZW50KGRhdGEpO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gJ2V4ZWN1dGVGdW5jdGlvbicpIHtcbiAgICAgICAgICBjb25zdCBmbiA9IHdpbmRvd1tkYXRhLnBheWxvYWQuZnVuY3Rpb25OYW1lXTtcbiAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBTcGVjaWFsIGNhc2UgdG8gcmVnaXN0ZXIgdGhlIHN0b3J5Ym9hcmRJZFxuICAgICAgICAgICAgbGV0IGFyZ3MgPSBkYXRhLnBheWxvYWQuYXJncztcbiAgICAgICAgICAgIGlmIChkYXRhLnBheWxvYWQuY29tcHJlc3NlZEFyZ3MpIHtcbiAgICAgICAgICAgICAgYXJncyA9IEpTT04ucGFyc2UobHouZGVjb21wcmVzcyhkYXRhLnBheWxvYWQuY29tcHJlc3NlZEFyZ3MpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRhdGEucGF5bG9hZC5mdW5jdGlvbk5hbWUgPT09ICdpbml0UHJvamVjdCcpIHtcbiAgICAgICAgICAgICAgc3Rvcnlib2FyZElkID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgYXJncyA9IGFyZ3Muc2xpY2UoMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkYXRhLnBheWxvYWQuYXJncykge1xuICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGZuKHBvcnQyLCBzdG9yeWJvYXJkSWQsIC4uLmFyZ3MpO1xuICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHJlc3VsdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBmbihwb3J0Miwgc3Rvcnlib2FyZElkKTtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCByZXN1bHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0lOTkVSIEZSQU1FIEVSUk9SOiBGdW5jdGlvbiB0byBleGVjdXRlIG5vdCBmb3VuZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICBjb25zb2xlLmxvZygnSU5ORVIgRlJBTUUgRVJST1I6ICcsIGVycm9yKTtcbiAgICAgICAgLy8gVE9ETzogU2VuZCBlcnJvciBiYWNrIHRvIHBhcmVudD9cbiAgICAgIH1cbiAgICB9O1xuICB9KSgpO1xufVxuIl19